\documentclass[a4paper]{report}

\usepackage[utf8]{inputenc}
\usepackage[a4paper]{geometry}

\begin{document}

\title{Stateless: a Technical Report}
\author{Habla Computing}
\date{June 2017}

\maketitle

\begin{abstract}

  Abstract goes here!

\end{abstract}

\tableofcontents

\chapter{Introduction}

Software industry as we know it lacks well founded frameworks to program
reactive systems\footnote{Reactive systems interact with their environment by
receiving inputs and providing outputs, they run possibly forever and they show
a black-box behaviour.} in a modular way. As a result, it is not hard to find
monolithic software that entangles different computational aspects and which is
quite difficult to reason about. Thankfully, \emph{Functional Programming} (FP)
provides such a wide range of modularity mechanisms, that it has recently become
essential to deal with the increasingly complex demands made by society.
\emph{Domain Specific Languages} (DSLs) are key elements for that success. As
their name suggests, these are languages that are exclusively focused on a
particular domain, delegating the irrelevant low-level details to their
particular interpretations. There are plenty of DSLs that conforms programs to
describe a kind of system evolution, such as \emph{SQL}, \emph{Slick} or even
\emph{akka-http}. However, we have missed for a long time a DSL whose algebra
was expressive enough to unify them all.

Coalgebra has been postulated as a unifying theory of systems. Indeed,
automatas, streams and objects, among many other machines, could be represented
by this abstraction. In spite of that fact, there seems to be little work on
providing coalgebraic programming libraries \emph{for the masses}. This might be
a consequence of the blurred boundary between algebraic and coalgebraic worlds.
In fact, any coalgebra could be seen as a state-based representation of an
algebra, as we informally showed in our blog\footnote{
https://blog.hablapps.com/2016/10/11/yo-dawg-we-put-an-algebra-in-your-coalgebra/
https://blog.hablapps.com/2016/11/10/lens-state-is-your-father/}. Starting from
a lens represented as a (costate comonad) coalgebra, we ended up claiming that
it could also be represented as a particular interpretation of
\emph{MonadState}. State and lens connections arise everywhere but this one led
us to ask ourselves further questions. Mainly, if \emph{MonadState} is the
algebra for lens, what is the corresponding algebra for the rest of optics?

Once applied a similar derivation for each optic we collected a group of
algebras and packed them in a Scala library, which we affectionately named
\emph{stateless}. Some of those algebras were actually widespread in the
community, such as \emph{MonadState} for lens or \emph{MonadReader} for getter.
However, some new algebras which were absolutely new to us emerged in the
process. Most importantly, we noticed that our algebras could be casted and
composed following the same rules that govern optic
hierarchies\footnote{http://julien-truffaut.github.io/Monocle/optics.html}.
However, composition was clumsy, manifesting an analogous situation to the one
that arises when composing classic optics, eg. a lens represented with a pair of
functions \emph{get} and \emph{set}. In that context, Van-Laarhoven and recently
Profunctor representations offer a composable solution. Thereby, we tried to
represent our algebras with a different approach, resulting in what we named
\emph{natural} representation, since it heavily relies on natural
transformations. Indeed, natural transformations know how to turn a program over
the focus into a program over the whole, where inner and outer programs are not
necessarily the same. As a consequence, algebra composition becomes quite
flexible and intuitive.

% Map-alike algebras -> Indexed optics -> Symmetric optics

Optic algebras bring optic capabilities to a generic setting. The language they
provide could be used to describe a system in a modular way, by establishing
dependencies with nested subsystems in terms of dependencies with inner
programs. Given that situation, we could specify that a \emph{university} system
is made of \emph{department} subsystems, where traversal algebra is the optic
that establishes the glue among both. Once the system is described, we could
instantiate it with a naive state monad or with a mixing of Slick (for the
university global information) and microservices (to keep every department
updated) or with any other configuration we could think of. Undoubtedly, optics
are key abstractions to achieve complex transformations of data. We claim that
optic algebras achieve analogous complex transformations at a higher abstraction
level, and therefore, they are suitable to unify different state-based DSLs.
Besides, they are very close to an object-oriented mindset, since we can
consider systems as classes where optics are the mechanism that determines
dependencies and cardinalities with other classes. That is the reason why we
suggest that stateless is a coalgebra-inspired library that could be potentially
used by the masses to program reactive systems.

The rest of this paper is structured as follows\ldots

\chapter{Background}
\section{Optics: Lenses and Beyond}
\section{Optic Representations}
\subsection{Classic}
\subsection{Van-Laarhoven}
\subsection{Profunctor}
\section{Optics and State Connections}
\subsection{BX Transformations}
\subsection{[Monocle] State Module}
\section{Initial Algebras (Free, Tagless)}

\chapter{Body}
\section{Why Stateless?}
\section{Optic Algebras}
\section{Natural Representation}
\section{Operation Algebras (At, FilterIndex, etc.)}
\section{Standard Library (Map, etc.)}
\section{Indexed and Symmetric Algebras}
\section{Instances}
\subsection{Memory}
\subsection{Database}
\subsection{Microservices}

\chapter{Example: University}

\chapter{Conclusions and Future Work}
\section{Related Work}
\section{Discussion}
\section{Future Work}

\end{document}
