\documentclass[a4paper]{article}

\usepackage[a4paper]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{xargs}
\usepackage[pdftex,dvipsnames]{xcolor}

%
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}
\newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}
%

\begin{document}

\lstset{language=Scala}

\title{Stateless: an Optic Algebra Library}
\author{
  Jesús López-González\\
  \texttt{j.lopezgo@alumnos.urjc.es}
  \and
  Juan Manuel Serrano\\
  \texttt{juanmanuel.serrano@urjc.es}
  \and
  Javier Fuentes\\
  \texttt{javier.fuentes@hablapps.com}
}

\maketitle

\begin{abstract}

  Abstract goes here!

\end{abstract}

\section{Introduction}

% The problem: 1st part

\improvement{Provide solid references!}Software industry as we know it lacks
well-founded frameworks to program reactive systems in a modular way. This kind
of systems hide an inner \emph{state} to their environment, showing therefore a
black-box behaviour. Take a university information system as a guiding example.
Universities are structured in departments, and in turn, each department has a
budget. Even this simple definition does contain three kinds of entities:
universities, departments and budgets. Ideally, programming the evolving state
of the whole system should be achieved by programming the state of each entity
or subsystem, and finally composing them all.

In addition, composition should contemplate heterogeneity: departments could be
stored in a local database while budget could be deployed as external
microservices. Ultimately, any configuration should be supported, but it is
essential for the system description to remain pure and decoupled from low-level
details, irrelevant to the domain. Needless to say that it should never hamper
optimal performance. Programming a declarative and modular system in this way is
still a great challenge, but functional programming is a good place to
start~\cite{hughes1989functional}.

% The problem: 2nd part

There are plenty of technologies to develop reactive systems, but they are
postulated as solutions to specific problems, and consequently, difficult to be
reused. Turning to the university example, we could have decided to program
department evolution on a relational database, like \emph{MySQL}. However, if
larger volumes of data arose in time, migrating to a distributed database such
as \emph{Redis} might become necessary. Given that situation, we would find it
extremely difficult to adapt existing encodings to the new setting.

Fortunately, industry has detected this issue and new abstract tools have
emerged to fill the gap. In this sense, we could have avoided the aforementioned
problem by programming department evolution with \emph{Slick}, a
Functional-Relational Mapper that provides an \emph{embedded domain specific
language}~\cite{hudak1996building} that can be later interpreted into different
databases. Even though this language is a great help in this scenario, it is
still quite limited to deal with database technologies. What if we change our
mind and decide to implement department as a microservice?

We claim that many of these languages to access state could be further
factorized, by providing a new language to unify them, while retaining
reasonable levels of performance for a large class of applications. Moreover, we
claim that the fundamentals behind \emph{optics} ---being
\emph{lens}~\cite{foster2005combinators} its main representative --- are ideal
to abstract technology-specific details away. However, prior to that, they have
to be taken to a more general setting: \emph{optic algebras}.

% Deriving Optic algebras

Optic algebras distill the algebraic essence of an optic. To better understand
this concept, we need to see optics from a coalgebraic
perspective~\cite{jacobs2016introduction}. In this view, optics are just
machines ---that can possibly run forever~\cite{turner2004total}--- with buttons
that can be pressed to observe or forward the machine
state~\cite{jacobs1997tutorial}. In fact, what we mean by the algebraic essence
is just the description of the machine interface in terms of its buttons, where
any reference to the inner state has been abstracted away. The resulting
interfaces are what we know as optic algebras and are postulated as the building
blocks to program the state of our systems in a modular way.

% Natural Composition and Heterogeneity

Since composability is one of the most striking features of
optics~\cite{pickering2017profunctor}, one could imply similar abilities in
their algebraic counterparts. However, as we will see in further sections, optic
algebras in their \emph{raw} representation do not compose as expected. In order
to avoid that problem, we propose an alternative \emph{natural} representation
---since it relies on natural transformations~\cite{pierce1991basic}--- that
enables composition, in a similar way as for plain optics. Furthermore, this
representation is key to introduce the notion of heterogeneity.

% Instances for Free

\todo{This paragraph is awful, it should contain more insights on instances!}
Optic algebra instances for the most widespread deployments should be provided.
Given this scenario, by defining our system in terms of optic algebras, we
should be able to get our logic implemented once and for all. Later, we could
find it interpreted into a method call, a database access, a microservice
invocation, or even as a combination of many of them.

% So

We claim that optic algebras in their natural representation lead to modular
software designs. For instance, a traversal algebra could establish the
connection between the university and each department. On the other hand, a lens
algebra could describe the relationship between departments and budget. Then, we
could compose both algebras to conform the whole system. Additionally, optic
algebras will enable us to do it in an heterogeneous way, with several free
instances ready to go, offering a reasonable performance for the majority of
cases.

% Paper organization

The rest of the paper is organized as follows.\todo{Fulfill this paragraph when
organization becomes clear}

\section{Background}

\subsection{Monads}
% State Monad y MonadState (with laws)

\subsection{Optics}
\label{sub:background.optics}

\subsubsection{Lens}
\label{subsub: background.optics.lens}

\begin{lstlisting}
trait Lens[S, A] {
  def get(s: S): A
  def set(a: A): S => S
}
\end{lstlisting}

\begin{align*}
  & set(get(s))(s) = s &&\textbf{GetPut} \\
  & get(set(a)(s)) = a &&\textbf{PutGet} \\
  & set(a2)(set(a1)(s)) = set(a2)(s) &&\textbf{PutPut}
\end{align*}

\subsubsection{Getter}

\begin{lstlisting}
trait Getter[S, A] {
  def get(s: S): A
}
\end{lstlisting}

\subsubsection{Setter}

\begin{lstlisting}
trait Setter[S, A] {
  def modify(f: A => A): S
}
\end{lstlisting}

\begin{align*}
  & modify(identity)(s) = s &&\textbf{ModId} \\
  & modify(g)(modify(f)(s)) = modify(g compose f)(s) &&\textbf{ModComp} \\
\end{align*}

\subsubsection{Fold}

\begin{lstlisting}
trait Fold[S, A] {
  def getList(s: S): List[A]
}
\end{lstlisting}

\subsubsection{Traversal}

\unsure{For a fixed N}
\begin{lstlisting}
trait Traversal[S, A] {
  def getList(s: S): List[A]
  def setList(as: List[A]): S => S
}
\end{lstlisting}

\begin{align*}
  & setList(getList(s))(s) = s &&\textbf{GetPut} \\
  & getList(setList(as)(s)) = as &&\textbf{PutGet} \\
  & setList(as2)(setList(as1)(s)) = setList(as2)(s) &&\textbf{PutPut}
\end{align*}

\subsubsection{Affine Traversal}

\begin{lstlisting}
trait Affine[S, A] {
  def getOption(s: S): Option[A]
  def set(a: A): S => S
}
\end{lstlisting}

\change{This laws makes no sense, take a look at haskell file}
\begin{align*}
  & getOption(s).map(a => set(a)(s)) = s &&\textbf{GetSet} \\
  & getOption(set(a)(s)) = getOption(s).as(a) &&\textbf{SetGet} \\
  & set(a2)(set(a1)(s)) = set(a2)(s) &&\textbf{SetSet} \\
\end{align*}

\subsubsection{Prism}

\begin{lstlisting}
trait Prism[S, A] {
  def getOption(s: S): Option[A]
  def reverseGet(a: A): S
}
\end{lstlisting}

\begin{align*}
  & getOption(s).map(reverseGet) = s &&\textbf{GetRev} \\
  & getOption(reverseGet(a)) = Some(a) &&\textbf{RevGet} \\
\end{align*}

\subsubsection{Iso}

\begin{lstlisting}
trait Iso[S, A] {
  def get(s: S): A
  def reverseGet(a: A): S
}
\end{lstlisting}

\begin{align*}
  & reverseGet(get(s)) = s &&\textbf{GetRev} \\
  & get(reverseGet(a)) = a &&\textbf{RevGet} \\
\end{align*}

% State Module

\subsection{Machines}
% IOCoalgebras, extracting buttons

\section{Deriving Optic Algebras}

Previously, in section \ref{sub:background.optics}, optics were shown as crucial
abstractions to access certain state, particularly, they provide access to
in-memory data structures. Furthermore, we discussed that this effect could be
perfectly modeled with the \emph{State Monad}. Thereby, optics enable
programmers to describe a whole range of complex transformations as State
programs. Having said so, it would be great to take this potential to other
\emph{stateful} scenarios.

Optic algebras distill optics to extract their algebraic essence. More
specifically, they abstract all the in-memory specific details away, to make the
optic potentially exploitable in new contexts, such as relational databases,
microservices or event sourcing, among others. The remainder of this section
will turn the most prominent optics into their corresponding algebraic
representation, beginning with lens.

\subsection{Lens Algebra}

How could one extract the essence of a lens? What does it mean to abstract the
in-memory details away? Well, we know that lenses can be represented as a pair
of functions: \emph{get} and \emph{set}. Those functions are aware of the
existence of an outer state, and they use it to extract the focus from, and to
set a new value for the focus to. Our main objective here is to abstract away
any reference to that outer state. We do so with the following steps:

\begin{proof}
  \improvement{This proof is not a proof at all, lier!}
  Let $s, a$ be types representing the whole and the focus of certain lens,
  respectively. So,
  \begin{align*}
    (get, set) \\
    &= (s \rightarrow a,\ a \rightarrow s \rightarrow s) &&\text{(expand definitions)} \\
    &= (() \rightarrow s \rightarrow a,\ a \rightarrow s \rightarrow s) &&\text{(homogenize input)} \\
    &= (() \rightarrow s \rightarrow a,\ a \rightarrow s \rightarrow (s,\ ())) &&\text{(homogenize output)} \\
    &= (() \rightarrow s \rightarrow (s,\ a),\ a \rightarrow s \rightarrow (s,\ ())) &&\text{(homogenize resulting state *)} \\
    &= (() \rightarrow State\ s\ a,\ a \rightarrow State\ s\ ()) &&\text{(State isomorphism)} \\
    &\therefore (() \rightarrow f\ a,\ a \rightarrow f\ ()) &&\text{(Abstract away)}\qedhere
  \end{align*}
\end{proof}

The first step after expanding definitions consists of making the input in both
functions homogeneous. Since \emph{set} receives an \emph{A} as first parameter,
something has to be added as a first argument in \emph{get}. Thereby, by
applying simple algebraic rules, we can safely prepend a redundant \emph{Unit}
typed parameter.

Secondly, we homogenize output. In this sense, \emph{get} is returning an $A$ as
output, while \emph{set} is only returning the updated value for $S$. If we want
the latter to return its own output, we have to provide a redundant \emph{Unit}
accompanying the resulting state $S$.

Thirdly, once we have homogenized the output value, it should be desirable to
homogenize the resulting state as well. To do so, we create a contrived $S$ as
companion of the output $A$, which will contain the second parameter as is. This
step is tricky, since it is not a valid equivalence per se. Therefore, in order
to formalize it, we have to impose that the resulting state has to be exactly
the same as the incoming one, as a new law for our derived
\emph{get}.\improvement{Make this clear somehow in the corresponding step}

Finally, it is not hard to see that the right hand side of the resulting
functions corresponds with the state monad, being $S$ the underlying state.
Given this isomorphism, we can say we have our functions homogenized, both
getting certain input and returning a stateful program. If you remember our
initial objective, we wanted to abstract all those references to the outer state
$S$ away. Now, it is easy to do so, we just have to turn \emph{State[S, ?]} into
a generic type constructor \emph{F[?]}. Hopefully, the resulting pair should be
familiar to the reader.

We started our derivation trying to remove low-level details from our lens and
we ended up with something really similar to \emph{MonadState}. As you can see,
we are lacking the monadic combinators to fully complete the connection. At
first glance, this seems like a big gap, but you will be pleased to hear that we
are not that far, we just need to bring lens laws into the picture.

Lens laws have an important role to connect the resulting algebra with
\emph{MonadState}. You must recall that a lens is not only a pair of functions,
it is closely tied to the lens laws: \emph{PutPut}, \emph{GetPut} and
\emph{PutGet}. Therefore, they have to be taken into account in the derivation
process, because they also mutate along with the pair of functions. Those
adaptations are a walk in the park, but there is a particular point when the law
adaptation no longer makes sense.

What does the \emph{GetPut} law mean right after the last step? In fact, there
is no way to establish a connection between the pair of functions at this level
of $f$ abstraction, unless we provide such mechanism with monadic combinators.
Given this situation, it is reasonable to extend our algebra with \emph{Monad},
because laws have to be adapted into this abstract setting. Luckily, we do not
have to do such work, because this step has already be done. In fact, by
adapting lens laws to the new monadic setting, we are just reinventing
\emph{MonadState} laws.

The lens and \emph{MonadState} laws correspondence is straightforward, however
\emph{MonadState} has an additional intruder which is not contemplated in the
lens laws: \emph{GetGet}. So, we could think that \emph{MonadState} is imposing
additional restrictions to the ones that we adapted from lens laws.
Nevertheless, we should recall that we added an additional law to our
representation when we homogenized the resulting state. If we adapt it to the
abstract setting, we end up with somethink similar to this:
\begin{align*}
  get >> return\ () = return\ () &&\text{(XGet)}
\end{align*}
It tells us that instructing a $get$ and ignoring its result does not produce an
overall effect. It would be great if \emph{GetGet} could be derived from
\emph{XGet}. We show that this is possible:

\begin{proof}
  \unsure{Any leap of faith in this process?}
  \improvement{Monad laws steps are quite abrupt}
  GetGet can be derived from XGet
  \begin{align*}
    GetGet \\
    &= get >>= (a1 \rightarrow get >>= (a2 \rightarrow return\ (a1, a2))) =\\ &\ \ \ \ get >>= (a \rightarrow return\ (a, a)) &&\text{(GetGet)} \\
    &= get >>= (a1 \rightarrow get >>= (a2 \rightarrow return\ (a1, a2))) >> return\ () =\\&\ \ \ \ get >>= (a \rightarrow return\ (a, a)) >> return\ () &&\text{(Monad laws)} \\
    &= get >>= (a1 \rightarrow get >>= (a2 \rightarrow return\ ())) = get >>= (a \rightarrow return\ ()) &&\text{(Monad laws)} \\
    &= get >> get >> return\ () = get >> return\ () &&\text{(Syntax)} \\
    &= get >> return\ () = get >> return\ () &&\text{(XGet)}\qedhere
  \end{align*}
\end{proof}

By establishing this connection we can say that the adaptation of lens laws,
including the one that emerged in the abstraction process, corresponds directly
with \emph{MonadState} laws. Thereby, we claim that the algebraic essence of a
lens is exactly \emph{MonadState}. In fact, this typeclass abstract away all
those in-memory specific details while preserving the lens laws.

\subsection{Getter Algebra}

Next, we will derive the optic algebra associated to \emph{getter}. In fact, it
is not hard to notice that this optic is a simplification of lens, where we are
only interested in the \emph{getting} capabilities. The derivation process to
obtain a getter algebra is therefore:

\begin{proof}
  Let $s, a$ be types representing the whole and the focus of certain getter,
  respectively. So,
  \begin{align*}
    get \\
    &= s \rightarrow a &&\text{(expand definitions)} \\
    &= () \rightarrow s \rightarrow a &&\text{(homogenize input)} \\
    &= () \rightarrow s \rightarrow (s,\ a) &&\text{(homogenize resulting state *)} \\
    &= () \rightarrow State\ s\ a &&\text{(State isomorphism)} \\
    &\therefore () \rightarrow f\ a &&\text{(Abstract away)}\qedhere
  \end{align*}
\end{proof}

As one can see, the process is exactly the same as the one we applied over the
first component of the pair of functions that represent a lens. What are the
laws associated to this algebra? Since getter has no attached laws, the only one
that should be associated to the new abstraction is \emph{XGet}, which emerged
while homogenizing the resulting state.

Is this algebra already known in the folklore? At first glance, we could think
that \emph{MonadReader} is the closest one to match. However, this typeclass
declares an additional method \emph{local} and consequently, new laws are
required. It seems that we only need part of the definition of
\emph{MonadReader}. Indeed, some functional programming libraries do reflect
this separation, resulting in the \emph{MonadAsk}
typeclass\footnote{https://github.com/purescript/purescript-transformers/blob/master/src/Control/Monad/Reader/Class.purs\#L16},
which perfectly fulfills our algebra. As expected, it has a unique law, which
corresponds with our \emph{XGet}.

\subsection{Setter Algebra}

\emph{Setter} ignores the lens getting part and focuses on the setting one. As
we saw previously, it is slightly more powerful, since it is defined in terms of
a \emph{modify} method. As usual, we show now the derivation process:

\begin{proof}
  Let $s, a$ be types representing the whole and the focus of certain setter,
  respectively. So,
  \begin{align*}
    set \\
    &= (a \rightarrow a) \rightarrow s \rightarrow s &&\text{(expand definitions)} \\
    &= (a \rightarrow a) \rightarrow s \rightarrow (s,\ ()) &&\text{(homogenize output)} \\
    &= (a \rightarrow a) \rightarrow State\ s\ () &&\text{(State isomorphism)} \\
    &\therefore (a \rightarrow a) \rightarrow f\ () &&\text{(Abstract away)}\qedhere
  \end{align*}
\end{proof}

These steps do not generate new laws, so our resulting setter algebra laws will
be just an adaptation of the setter optic ones. Since we have not found this
algebra in the literature\footnote{There are references to \emph{MonadPut}
though.}, we propose the next laws:

\begin{align*}
  & modify\ id = return\ () &&\textbf{ModId} \\
  & modify\ f >> modify\ g = modify\ (g\ .\ f) &&\textbf{ModComp}
\end{align*}

\subsection{Fold Algebra}

Fold algebras slightly modify getter algebras, returning a list of $a$s instead
of a single one. Thereby, derivation process is almost identical:

\begin{proof}
  Let $s, a$ be types representing the whole and the focus of certain fold,
  respectively. So,
  \begin{align*}
    getList \\
    &= s \rightarrow \left[a\right] &&\text{(expand definitions)} \\
    &= () \rightarrow s \rightarrow \left[a\right] &&\text{(homogenize input)} \\
    &= () \rightarrow s \rightarrow (s,\ \left[a\right]) &&\text{(homogenize resulting state *)} \\
    &= () \rightarrow State\ s\ \left[a\right] &&\text{(State isomorphism)} \\
    &\therefore () \rightarrow f\ \left[a\right] &&\text{(Abstract away)}\qedhere
  \end{align*}
\end{proof}

As far as we are concerned, no mainstream typeclass matches the expected
algebra. However, taking getter algebra law as template, fold algebra one is
straightforward.

\subsection{Affine Traversal Algebra}

\begin{proof}
  Let $s, a$ be types representing the whole and the focus of certain affine traversal, respectively. So,
  \begin{align*}
    (getMaybe, set) \\
    &= (s \rightarrow Maybe\ a,\ a \rightarrow s \rightarrow s) &&\text{(expand definitions)} \\
    &= (() \rightarrow s \rightarrow Maybe\ a,\ a \rightarrow s \rightarrow s) &&\text{(homogenize input)} \\
    &= (() \rightarrow s \rightarrow Maybe\ a,\ a \rightarrow s \rightarrow (s,\ ())) &&\text{(homogenize output)} \\
    &= (() \rightarrow s \rightarrow (s,\ Maybe\ a),\ a \rightarrow s \rightarrow (s,\ ())) &&\text{(homogenize resulting state *)} \\
    &= (() \rightarrow State\ s\ (Maybe\ a),\ a \rightarrow State\ s\ ()) &&\text{(State isomorphism)} \\
    &\therefore (() \rightarrow f\ (Maybe\ a),\ a \rightarrow f\ ()) &&\text{(Abstract away)}\qedhere
  \end{align*}
\end{proof}

Laws for emerging algebra:

\begin{align*}
  & getMaybe >>= (maybe\ (return\ ())\ set) = return\ () &&\textbf{GetmSet} \\
  & set\ a >> getMaybe = getMaybe\ \$> a &&\textbf{SetGetm} \\
  & set\ a1 >> set\ a2 = set\ a2 &&\textbf{SetSet} \\
  & getOption >> return\ () = return\ () &&\textbf{GetmGetm} \\
\end{align*}

\subsection{Traversal Algebra}

\improvement{Not a traversal, maybe we can call it \emph{Weak Traversal}}

\begin{proof}
  Let $s, a$ be types representing the whole and the focus of certain traversal,
  respectively. So,
  \begin{align*}
    (getList, modify) \\
    &= (s \rightarrow \left[a\right],\ (a \rightarrow\ a) \rightarrow s \rightarrow s) &&\text{(expand definitions)} \\
    &= (() \rightarrow s \rightarrow \left[a\right],\ (a \rightarrow\ a) \rightarrow s \rightarrow s) &&\text{(homogenize input)} \\
    &= (() \rightarrow s \rightarrow \left[a\right],\ (a \rightarrow\ a) \rightarrow s \rightarrow (s,\ ())) &&\text{(homogenize output)} \\
    &= (() \rightarrow s \rightarrow (s,\ \left[a\right]),\ (a \rightarrow\ a) \rightarrow s \rightarrow (s,\ ())) &&\text{(homogenize resulting state *)} \\
    &= (() \rightarrow State\ s\ \left[a\right],\ (a \rightarrow\ a) \rightarrow State\ s\ ()) &&\text{(State isomorphism)} \\
    &\therefore (() \rightarrow f\ \left[a\right],\ (a \rightarrow\ a) \rightarrow f\ ()) &&\text{(Abstract away)}\qedhere
  \end{align*}
\end{proof}

Laws for emerging algebra:
\info{GetlMod makes no sense, it would have been different if we had \emph{setList} available}
\info{These laws are our own! Remember, this isn't a standard Traversal.}
\begin{align*}
  & modify\ id = return\ () &&\textbf{ModId} \\
  & modify\ f >> modify\ g = modify\ (g\ .\ f) &&\textbf{ModMod} \\
  & modify\ f >> getList = getList >>!\ modify\ f >>= (return\ .\ map\ f) &&\textbf{ModGetl} \\
  & getList >> return\ () = return\ () &&\textbf{GetlGetl} \\
\end{align*}

\subsection{Other Optic Algebras}

\unsure{What does this bring us?} \unsure{Is Iso really an asymmetric optic?
(connections with symmetric are obvious)} Iso \& Lens share algebra. Prism \&
Affine share algebra.

\section{Natural Composition and Heterogeneity}
% This section must include transformation between optics (as a composition flavor)

Once our optic algebras are defined, we could be interested in combining them,
just as plain optics are combined. However, when we move to this scenario, the
situation becomes more complicated. As we know, lenses compose when the
\emph{focus} of the first lens matches the \emph{whole} of the second one.
However, our optic algebras have a type constructor as weird \emph{whole} and a
concrete type as \emph{focus}, which leads to an odd scenario.

Therefore, we need to ask ourselves what does it mean to compose a pair of optic
algebras. For instance, suppose we want to compose \emph{TraversalAlg f
Department} with \emph{LensAlg g Int}, as we showed in the university example.
The first one knows how to build \emph{f} programs to access all the
departments. On the other hand, the second instance builds \emph{g} programs to
access the budget. If we think of \emph{f} and \emph{g} as something
encapsulating the university and the department states, respectively, we could
determine that the composition of both algebras should be close to
\emph{TraversalAlg f Int}, ie. a program over the whole university that has
access to all the budgets.

Unluckily, the aforementioned composition is not possible, since additional
components are required to implement it. Particularly, a natural transformation
${q \rightsquigarrow p}$ would serve us to embed focus programs into whole ones.
Thereby, optic algebras cannot be composed as we compose plain optics, in an
autonomous way.

\section{Instances for Free}

\section{Conclusions and Future Work}

\section{Acknowledgements}
% MINECO

\bibliography{stateless}{}
\bibliographystyle{unsrt}

\end{document}
