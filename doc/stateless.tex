\documentclass[a4paper]{article}

\usepackage[a4paper]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{xargs}
\usepackage[pdftex,dvipsnames]{xcolor}

%
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
\newcommandx{\unsure}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
\newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
\newcommandx{\info}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}}
\newcommandx{\improvement}[2][1=]{\todo[linecolor=Plum,backgroundcolor=Plum!25,bordercolor=Plum,#1]{#2}}
\newcommandx{\thiswillnotshow}[2][1=]{\todo[disable,#1]{#2}}
%

\begin{document}

\title{Stateless: an Optic Algebra Library}
\author{
  Jesús López-González\\
  \texttt{j.lopezgo@alumnos.urjc.es}
  \and
  Juan Manuel Serrano\\
  \texttt{juanmanuel.serrano@urjc.es}
  \and
  Javier Fuentes\\
  \texttt{javier.fuentes@hablapps.com}
}

\maketitle

\begin{abstract}

  Abstract goes here!

\end{abstract}

\section{Introduction}

% The problem: 1st part

\improvement{Provide solid references!}Software industry as we know it lacks
well-founded frameworks to program reactive systems in a modular way. This kind
of systems hide an inner \emph{state} to their environment, showing therefore a
black-box behaviour. Take a university information system as a guiding example.
Universities are structured in departments, and each has a budget. Even this
simple definition does contain three kinds of entities: universities,
departments and budget. Ideally, programming the evolving state of the whole
system should be achieved by programming the state of each entity or subsystem,
and finally composing them all.

In addition, composition should contemplate heterogeneity: departments could be
stored in a local database while budget could be deployed as external
microservices. Ultimately, any configuration should be supported, but it is
essential for the system description to remain pure and decoupled from low-level
details, irrelevant to the domain. Needless to say that it should never hamper
optimal performance. Programming a declarative and modular system in this way is
still a great challenge, but functional programming seems like a good starting
point ~\cite{hughes1989functional}.

% The problem: 2nd part

There are plenty of technologies to develop reactive systems, but they are
postulated as solutions to very specific problems, and consequently, difficult
to be reused. Turning to the university example, we could have decided to
program department evolution on a relational database, like \emph{MySQL}.
However, if large volumes of data arose in time, migrating to a distributed
database such as \emph{Redis} might become necessary. Given that situation, we
would find it extremely difficult to adapt existing encodings to the new
setting.

Fortunately, industry has detected this issue and new abstract tools have
emerged to fill the gap. In this sense, we could have avoided the aforementioned
problem by programming department evolution with \emph{Slick}, a
Functional-Relational Mapper that provides an \emph{embedded domain specific
language} ~\cite{hudak1996building} which can be later interpreted into
different databases. Similarly, we could find other situations where a common
language could unify different state evolutions. Take \emph{optics} as an
example. They could be seen as a language to achieve complex transformations
over immutable in-memory data. In this scenario, \emph{Traversal}
~\cite{o2011functor} could be used as the glue to keep university and department
related.

We claim that many of these languages to access state could be further
factorized, by providing a new language to unify them, while retaining
reasonable levels of performance for a large class of applications. Moreover, we
claim that optic concepts are ideal to abstract technology-specific details
away. However, prior to that, they have to be taken to a more general setting:
\emph{optic algebras}.

% Deriving Optic algebras

An optic algebra represents the essence of the state transformation associated
to that optic. Generally speaking, optics were conceived to tackle a very
specific problem, achieving complex transformations over immutable in-memory
data structures. For instance, a \emph{lens} ~\cite{foster2005combinators} knows
how to transform certain data structure ---the focus--- which is contextualized
in a larger one ---the whole. Regarding our university, this abstraction could
perfectly describe the existing relationship between a department and its
associated budget. Having said so, what do we mean by the essence of a lens?

\unsure{I'd like to avoid showing snippets in the intro!}The essence of a lens
requires removing all those aspects which are specific to in-memory
transformations. If we take into account the classic definition of a lens in
Scala ~\cite{morris2012asymmetric}:
\begin{align*}
(s \rightarrow a,\ a \rightarrow s \rightarrow s)
\end{align*}
one could easily identify several accesses to the in-memory state \emph{S}. If
we abstract away from those aspects, ie. if we conceal the state, we end up with
the optic algebra associated to lens:
\begin{align*}
(s \rightarrow f\ a,\ a \rightarrow f\ ())
\end{align*}
This algebra ---which bears a strong resemblance to \emph{MonadState}
~\cite{gibbons2012unifying}--- determines the existence of a focus that could be
either read or updated, but it keeps itself unaware of the details underneath
\emph{F}. Similar derivations could be carried out over other optics, resulting
in new optic algebras.

% Natural Composition and Heterogeneity

Composing optic algebras ---as they were introduced in the previous paragraph---
is not straightforward at all. In fact, the situation is very similar to the one
that emerges when trying to compose optics in their classic representation. In
this sense, Van Laarhoven and recently Profunctor optics
~\cite{pickering2017profunctor} have been postulated as alternative
representations to improve composition. Taking them as inspiration, we created a
new representation for optic algebras. Since it heavily relies on natural
transformations ~\cite{pierce1991basic}, we refer to it as \emph{natural}
representation. This representation not only improves the composition up, but
also introduces the notion of heterogeneity, as we will see in further sections.

% Instances for Free, move abstraction issue to the beginning!

Optic algebra instances for the most widespread deployments should be provided.
Given this scenario, by defining our system in terms of optic algebras, we
should be able to get our logic implemented once and for all. Later, we could
find it interpreted into a method call, a database access, a microservice
invocation, or even as a combination of many of them.

% So

We claim that optic algebras in their natural representation lead to modular
software designs. For instance, a traversal algebra could establish the
connection between the university and each department. On the other hand, a lens
algebra could describe the relationship between departments and budget. Then, we
could compose both algebras to conform the whole system. Additionally, optic
algebras will enable us to do it in an heterogeneous way, with many free
instances ready to go, offering a reasonable performance in the majority of
cases.

\section{Background}

\subsection{Monads}
% State Monad y MonadState (with laws)

\subsection{Optics}
\label{sub:background.optics}
% State Module

\section{Deriving Optic Algebras}

Previously, in section \ref{sub:background.optics}, optics were shown as crucial
abstractions to access certain state, particularly, they provide access to
in-memory data structures. Furthermore, we discussed that this effect could be
perfectly modeled with the \emph{State Monad}. Thereby, optics enable
programmers to describe a whole range of complex transformations as State
programs. Having said so, it would be great to take this potential to other
\emph{stateful} scenarios.

Optic algebras distill optics to extract their algebraic essence. More
specifically, they abstract all the in-memory specific details away, to make the
optic potentially exploitable in new contexts, such as relational databases,
microservices or event sourcing, among others. The remainder of this section
will turn the most prominent optics into their corresponding algebraic
representation, beginning with lens.

\subsection{Lens Algebra}

How could one extract the essence of a lens? What does it mean to abstract the
in-memory details away? Well, we know that lenses can be represented as a pair
of functions: \emph{get} and \emph{set}. Those functions are aware of the
existence of an outer state, and they use it to extract the focus from, and to
set a new value for the focus to. Our main objective here is to abstract away
any reference to that outer state. We do so with the following steps:

\begin{proof}
  \improvement{This proof is not a proof at all, lier!}
  Let $s, a$ be types representing the whole and the focus of certain lens,
  respectively. So,
  \begin{align*}
    (get, set) \\
    &= (s \rightarrow a,\ a \rightarrow s \rightarrow s) &&\text{(expand definitions)} \\
    &= (() \rightarrow s \rightarrow a,\ a \rightarrow s \rightarrow s) &&\text{(homogenize input)} \\
    &= (() \rightarrow s \rightarrow a,\ a \rightarrow s \rightarrow (s,\ ())) &&\text{(homogenize output)} \\
    &= (() \rightarrow s \rightarrow (s,\ a),\ a \rightarrow s \rightarrow (s,\ ())) &&\text{(homogenize resulting state *)} \\
    &= (() \rightarrow State\ s\ a,\ a \rightarrow State\ s\ ()) &&\text{(State isomorphism)} \\
    &\therefore (() \rightarrow f\ a,\ a \rightarrow f\ ()) &&\text{(Abstract away)}\qedhere
  \end{align*}
\end{proof}

The first step after expanding definitions consists of making the input in both
functions homogeneous. Since \emph{set} receives an \emph{A} as first parameter,
something has to be added as a first argument in \emph{get}. Thereby, by
applying simple algebraic rules, we can safely prepend a redundant \emph{Unit}
typed parameter.

Secondly, we homogenize output. In this sense, \emph{get} is returning an $A$ as
output, while \emph{set} is only returning the updated value for $S$. If we want
the latter to return its own output, we have to provide a redundant \emph{Unit}
accompanying the resulting state $S$.

Thirdly, once we have homogenized the output value, it should be desirable to
homogenize the resulting state as well. To do so, we create a contrived $S$ as
companion of the output $A$, which will contain the second parameter as is. This
step is tricky, since it is not a valid equivalence per se. Therefore, in order
to formalize it, we have to impose that the resulting state has to be exactly
the same as the incoming one, as a new law for our derived
\emph{get}.\improvement{Make this clear somehow in the corresponding step}

Finally, it is not hard to see that the right hand side of the resulting
functions corresponds with the state monad, being $S$ the underlying state.
Given this isomorphism, we can say we have our functions homogenized, both
getting certain input and returning a stateful program. If you remember our
initial objective, we wanted to abstract all those references to the outer state
$S$ away. Now, it is easy to do so, we just have to turn \emph{State[S, ?]} into
a generic type constructor \emph{F[?]}. Hopefully, the resulting pair should be
familiar to the reader.

We started our derivation trying to remove low-level details from our lens and
we ended up with something really similar to \emph{MonadState}. As you can see,
we are lacking the monadic combinators to fully complete the connection. At
first glance, this seems like a big gap, but you will be pleased to hear that we
are not that far, we just need to bring lens laws into the picture.

Lens laws have an important role to connect the resulting algebra with
\emph{MonadState}. You must recall that a lens is not only a pair of functions,
it is closely tied to the lens laws: \emph{PutPut}, \emph{GetPut} and
\emph{PutGet}. Therefore, they have to be taken into account in the derivation
process, because they also mutate along with the pair of functions. Those
adaptations are a walk in the park, but there is a particular point when the law
adaptation no longer makes sense.

What does the \emph{GetPut} law mean right after the last step? In fact, there
is no way to establish a connection between the pair of functions at this level
of $f$ abstraction, unless we provide such mechanism with monadic combinators.
Given this situation, it is reasonable to extend our algebra with \emph{Monad},
because laws have to be adapted into this abstract setting. Luckily, we do not
have to do such work, because this step has already be done. In fact, by
adapting lens laws to the new monadic setting, we are just reinventing
\emph{MonadState} laws.

The lens and \emph{MonadState} laws correspondence is straightforward, however
\emph{MonadState} has an additional intruder which is not contemplated in the
lens laws: \emph{GetGet}. So, we could think that \emph{MonadState} is imposing
additional restrictions to the ones that we adapted from lens laws.
Nevertheless, we should recall that we added an additional law to our
representation when we homogenized the resulting state. If we adapt it to the
abstract setting, we end up with somethink similar to this:
\begin{align*}
  get >> return\ () = return\ () &&\text{(XGet)}
\end{align*}
It tells us that instructing a $get$ and ignoring its result does not produce an
overall effect. It would be great if \emph{GetGet} could be derived from
\emph{XGet}. We show that this is possible:

\begin{proof}
  \unsure{Any leap of faith in this process?}
  \improvement{Monad laws steps are quite abrupt}
  GetGet can be derived from XGet
  \begin{align*}
    GetGet \\
    &= get >>= (a1 \rightarrow get >>= (a2 \rightarrow return\ (a1, a2))) =\\ &\ \ \ \ get >>= (a \rightarrow return\ (a, a)) &&\text{(GetGet)} \\
    &= get >>= (a1 \rightarrow get >>= (a2 \rightarrow return\ (a1, a2))) >> return\ () =\\&\ \ \ \ get >>= (a \rightarrow return\ (a, a)) >> return\ () &&\text{(Monad laws)} \\
    &= get >>= (a1 \rightarrow get >>= (a2 \rightarrow return\ ())) = get >>= (a \rightarrow return\ ()) &&\text{(Monad laws)} \\
    &= get >> get >> return\ () = get >> return\ () &&\text{(Syntax)} \\
    &= get >> return\ () = get >> return\ () &&\text{(XGet)}\qedhere
  \end{align*}
\end{proof}

By establishing this connection we can say that the adaptation of lens laws,
including the one that emerged in the abstraction process, corresponds directly
with \emph{MonadState} laws. Thereby, we claim that the algebraic essence of a
lens is exactly \emph{MonadState}. In fact, this typeclass abstract away all
those in-memory specific details while preserving the lens laws.

\subsection{Getter Algebra}

Next, we will derive the optic algebra associated to \emph{getter}. In fact, it
is not hard to notice that this optic is a simplification of lens, where we are
only interested in the \emph{getting} capabilities. The derivation process to
obtain a getter algebra is therefore:

\begin{proof}
  Let $s, a$ be types representing the whole and the focus of certain getter,
  respectively. So,
  \begin{align*}
    get \\
    &= s \rightarrow a &&\text{(expand definitions)} \\
    &= () \rightarrow s \rightarrow a &&\text{(homogenize input)} \\
    &= () \rightarrow s \rightarrow (s,\ a) &&\text{(homogenize resulting state *)} \\
    &= () \rightarrow State\ s\ a &&\text{(State isomorphism)} \\
    &\therefore () \rightarrow f\ a &&\text{(Abstract away)}\qedhere
  \end{align*}
\end{proof}

As one can see, the process is exactly the same as the one we applied over the
first component of the pair of functions that represent a lens. What are the
laws associated to this algebra? Since getter has no attached laws, the only one
that should be associated to the new abstraction is \emph{XGet}, which emerged
while homogenizing the resulting state.

Is this algebra already known in the folklore? At first glance, we could think
that \emph{MonadReader} is the closest one to match. However, this typeclass
declares an additional method \emph{local} and consequently, new laws are
required. It seems that we only need part of the definition of
\emph{MonadReader}. Indeed, some functional programming libraries do reflect
this separation, resulting in the \emph{MonadAsk}
typeclass\footnote{https://github.com/purescript/purescript-transformers/blob/master/src/Control/Monad/Reader/Class.purs#L16},
which perfectly fulfills our algebra. As expected, it has a unique law, which
corresponds with our \emph{XGet}.

\subsection{Setter Algebra}

\emph{Setter} ignores the lens getting part and focuses on the setting one. As
we saw previously, it is slightly more powerful, since it is defined in terms of
a \emph{modify} method. As usual, we show now the derivation process:

\begin{proof}
  Let $s, a$ be types representing the whole and the focus of certain setter,
  respectively. So,
  \begin{align*}
    set \\
    &= (a \rightarrow a) \rightarrow s \rightarrow s &&\text{(expand definitions)} \\
    &= (a \rightarrow a) \rightarrow s \rightarrow (s,\ ()) &&\text{(homogenize output)} \\
    &= (a \rightarrow a) \rightarrow State\ s\ () &&\text{(State isomorphism)} \\
    &\therefore (a \rightarrow a) \rightarrow f\ () &&\text{(Abstract away)}\qedhere
  \end{align*}
\end{proof}

These steps do not generate new laws, so our resulting setter algebra laws will
be just an adaptation of the setter optic ones. Since we have not found this
algebra in the literature\footnote{There are references to \emph{MonadPut}
though.}, we propose the next laws:

\begin{align*}
  & modify\ id = return\ () &&\textbf{ModId} \\
  & modify\ f >> modify\ g = modify\ (g\ .\ f) &&\textbf{ModComp}
\end{align*}

\subsection{Fold Algebra}

Fold algebras slightly modify getter algebras, returning a list of $a$s instead
of a single one. Thereby, derivation process is almost identical:

\begin{proof}
  Let $s, a$ be types representing the whole and the focus of certain fold,
  respectively. So,
  \begin{align*}
    getList \\
    &= s \rightarrow \left[a\right] &&\text{(expand definitions)} \\
    &= () \rightarrow s \rightarrow \left[a\right] &&\text{(homogenize input)} \\
    &= () \rightarrow s \rightarrow (s,\ \left[a\right]) &&\text{(homogenize resulting state *)} \\
    &= () \rightarrow State\ s\ \left[a\right] &&\text{(State isomorphism)} \\
    &\therefore () \rightarrow f\ \left[a\right] &&\text{(Abstract away)}\qedhere
  \end{align*}
\end{proof}

As far as we are concerned, no mainstream typeclass matches the expected
algebra. However, taking getter algebra law as template, fold algebra one is
straightforward.

\subsection{Affine Traversal Algebra}

\begin{proof}
  Let $s, a$ be types representing the whole and the focus of certain affine traversal, respectively. So,
  \begin{align*}
    (getMaybe, set) \\
    &= (s \rightarrow Maybe\ a,\ a \rightarrow s \rightarrow s) &&\text{(expand definitions)} \\
    &= (() \rightarrow s \rightarrow Maybe\ a,\ a \rightarrow s \rightarrow s) &&\text{(homogenize input)} \\
    &= (() \rightarrow s \rightarrow Maybe\ a,\ a \rightarrow s \rightarrow (s,\ ())) &&\text{(homogenize output)} \\
    &= (() \rightarrow s \rightarrow (s,\ Maybe\ a),\ a \rightarrow s \rightarrow (s,\ ())) &&\text{(homogenize resulting state *)} \\
    &= (() \rightarrow State\ s\ (Maybe\ a),\ a \rightarrow State\ s\ ()) &&\text{(State isomorphism)} \\
    &\therefore (() \rightarrow f\ (Maybe\ a),\ a \rightarrow f\ ()) &&\text{(Abstract away)}\qedhere
  \end{align*}
\end{proof}

Laws for emerging algebra:

\begin{align*}
  & getMaybe >>= (maybe\ (return\ ())\ set) = return\ () &&\textbf{GetmSet} \\
  & set\ a >> getMaybe = getMaybe\ \$> a &&\textbf{SetGetm} \\
  & set\ a1 >> set\ a2 = set\ a2 &&\textbf{SetSet} \\
  & getOption >> return\ () = return\ () &&\textbf{GetmGetm} \\
\end{align*}

\subsection{Traversal Algebra}

\improvement{Not a traversal, maybe we can call it \emph{Weak Traversal}}

\begin{proof}
  Let $s, a$ be types representing the whole and the focus of certain traversal,
  respectively. So,
  \begin{align*}
    (getList, modify) \\
    &= (s \rightarrow \left[a\right],\ (a \rightarrow\ a) \rightarrow s \rightarrow s) &&\text{(expand definitions)} \\
    &= (() \rightarrow s \rightarrow \left[a\right],\ (a \rightarrow\ a) \rightarrow s \rightarrow s) &&\text{(homogenize input)} \\
    &= (() \rightarrow s \rightarrow \left[a\right],\ (a \rightarrow\ a) \rightarrow s \rightarrow (s,\ ())) &&\text{(homogenize output)} \\
    &= (() \rightarrow s \rightarrow (s,\ \left[a\right]),\ (a \rightarrow\ a) \rightarrow s \rightarrow (s,\ ())) &&\text{(homogenize resulting state *)} \\
    &= (() \rightarrow State\ s\ \left[a\right],\ (a \rightarrow\ a) \rightarrow State\ s\ ()) &&\text{(State isomorphism)} \\
    &\therefore (() \rightarrow f\ \left[a\right],\ (a \rightarrow\ a) \rightarrow f\ ()) &&\text{(Abstract away)}\qedhere
  \end{align*}
\end{proof}

Laws for emerging algebra:
\info{GetlMod makes no sense, it would have been different if we had \emph{setList} available}
\info{These laws are our own! Remember, this isn't a standard Traversal.}
\begin{align*}
  & modify\ id = return\ () &&\textbf{ModId} \\
  & modify\ f >> modify\ g = modify\ (g\ .\ f) &&\textbf{ModMod} \\
  & modify\ f >> getList = getList >>!\ modify\ f >>= (return\ .\ map\ f) &&\textbf{ModGetl} \\
  & getList >> return\ () = return\ () &&\textbf{GetlGetl} \\
\end{align*}

\subsection{Other Optic Algebras}

\unsure{What does this bring us?} \unsure{Is Iso really an asymmetric optic?
(connections with symmetric are obvious)} Iso \& Lens share algebra. Prism \&
Affine share algebra.

\section{Natural Composition and Heterogeneity}
% This section must include transformation between optics

\section{Instances for Free}

\section{Conclusions and Future Work}

\section{Acknowledgements}

\bibliography{stateless}{}
\bibliographystyle{apalike}

\end{document}
