\documentclass[preview, 3p]{elsarticle}

\usepackage{amsmath,amsthm,amssymb}
\usepackage{listings}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}{Corollary}[theorem]

\def\bibsection{\section*{References}}

\journal{Somewhere to Publish}

\begin{document}

\begin{frontmatter}

\title{Optic Algebras: Beyond Immutable Data Structures}

\author[urjc,habla]{J.~Lopez-Gonzalez\corref{cor1}\fnref{fn1}}
\ead{j.lopezgo@alumnos.urjc.es}

\author[urjc,habla]{J.M.~Serrano}
\ead{j.serrano.hidalgo@urjc.es}

\cortext[cor1]{Corresponding author}

\fntext[fn1]{This is the specimen author footnote.}

\address[urjc]{Universidad Rey Juan Carlos}
\address[habla]{Habla Computing}

\begin{abstract}
Abstract goes here!
\end{abstract}

\end{frontmatter}

\lstset{language=Scala,
        basicstyle=\small,
        literate={~} {$\sim$}{1}}

\newtheorem*{remark}{Remark}

\section{Introduction}
\label{sec:Introduction}

Optics provide abstractions and patterns to access and update immutable data
structures. Specifically, they access and update \emph{focus} values which are
contextualized within a \emph{whole} data structure. There are different kinds
of optics in the
folklore\footnote{http://oleg.fi/gists/images/optics-hierarchy.svg}, each of
them describing a particular type of transformation. Among them, \emph{lens} has
become the most prominent one.

A lens do focus on a unique value that is always available from the whole data
structure. They turn out to be very useful to express transformations over
nested data structures~\cite{foster2005combinators}. As an example, consider the
following Scala classes~\cite{odersky2004overview}, where we use macro
annotations\footnote{This annotation is provided by \emph{Monocle}, the most
relevant optic library in the Scala ecosystem.} to generate a lens for each
field (or focus) of the annotated case class (or whole):

\begin{lstlisting}
package data

@Lenses case class Person(
  name: String,
  address: Address)

@Lenses case class Address(
  city: String,
  zip: Int)
\end{lstlisting}

Now suppose we want to modify the zip code associated to a person. Since lens
composition is closed~\cite{pickering2017profunctor}, we could express that
transformation by combining the lenses associated to \emph{address} and
\emph{zip} fields and then using the resulting one to invoke the modifying
method:

\begin{lstlisting}
def modZip(f: Int => Int): Person => Person =
  (address compose zip).modify(f)
\end{lstlisting}

Despite the elegance that we get to describe this kind of transformations,
lenses are restricted to work exclusively with in-memory data structures.
Imagine that we wanted to persist this person in a relational database using
\emph{Doobie} or \emph{Slick}. In this scenario, we would discard optics in
favor of the specific transformations provided by these technologies. Otherwise,
we would need to pull the whole state, modify it by means of a lens and finally
put it back again, which turns out to be completely impractical.

Firstly, we claim that it is possible to collect the essence of optics in a
domain specific language~\cite{hudak1996building}, aimed to take optic
abstractions and patterns beyond in-memory data structures. Secondly, we claim
that this language is expressive enough to implement the data layer of an
application and its associated logic once and for all, and later instantiate
them to particular state-based interpretations: in-memory data structures,
databases, microservices, etc. Lastly, we claim that we can do so while
retaining reasonable levels of performance for a large class of applications.
These are our contributions to fulfill our claims:

\begin{itemize}

\item We propose \emph{lens algebra} (section \ref{sec:Towards}), which distills
the algebraic essence of a lens. To better illustrate this idea, we need to see
lenses from a coalgebraic perspective~\cite{jacobs1995objects,
jacobs1997tutorial, oconnor2011functor}. In this sense, optics are just machines
---that can possibly run forever~\cite{turner2004total}--- with buttons that can
be pressed to observe or forward the machine state. In fact, what we mean by the
algebraic essence is just the description of the machine interface in terms of
its buttons, where any reference to the inner state has been abstracted away.

\item Lens algebras in their \emph{raw} formulation do not compose. In fact, it
is difficult to determine what we mean by composition at this level of
abstraction. To alleviate the situation, we propose a \emph{natural}
representation (section \ref{sec:Natural}) ---which heavily relies on natural
transformations~\cite{pierce1991basic}--- that enables composition for lens
algebras.

\item We take these ideas to other optics, particularly: \emph{getter},
\emph{setter}, \emph{fold}, \emph{affine} and \emph{weak traversal\footnote{This
is a relaxed traversal, where the transformation function for each focus must be
exactly the same.}}. As a result, we end up with a collection of algebras that
we refer to as \emph{optic algebras} (section \ref{sec:Generalizing}). These
algebras represent analogous transformations to their in-memory optic
counterparts, even preserving heterogeneous composition, but in a more general
setting.

\item We provide \emph{Stateless} (section \ref{sec:Stateless}), an optic
algebra library which is aimed to take these concepts and patterns to the
development of industrial applications in the Scala ecosystem.

\end{itemize}

Previously, when we stated that optic algebras pursue transforming state in
different settings, we actually meant that we want them to support different
state-based effects~\cite{wadler1995monads}. In this sense, there exists work
relating optics and effects, being \emph{monadic
lenses}~\cite{abou2016reflections} the most relevant one. Bidirectional
transformations~\cite{abou2015notions, abou2017coalgebraic} is also a great
source of effectful transformations. We will compare our approach with these
techniques in section \ref{sec:Discussion}.

\section{Towards more abstract lenses}
\label{sec:Towards}

As stated in~\cite{foster2005combinators}, lenses approach the view update
problem for tree-structured data.

\begin{definition}

A \emph{lens} consists of a pair of functions, one of them \emph{gets} the
part from the whole and the other one \emph{sets} a new part into an old whole,
returning a new whole. They are encoded in Scala as
follows~\cite{morris2012asymmetric}:

\begin{lstlisting}
case class Lens[S, A](
  get: S => A,
  set: (S, A) => S)
\end{lstlisting}
As you may figured out, $S$ and $A$ serve as the whole and the part,
respectively. Lens operations must obey certain laws to be considered very
well-behaved~\cite{fischer2015clear}:
\begin{align*}
  & set(s,\ get(s))\ =\ s &&\textbf{GetPut} \\
  & get(set(s,\ a))\ =\ a &&\textbf{PutGet} \\
  & set(set(a1,\ s),\ a2)\ =\ set(s,\ a2) &&\textbf{PutPut}
\end{align*}

\end{definition}

In section \ref{sec:Introduction} we saw that lens generation for the fields of
a case class is systematic, since we generated them automatically. Anyway, here
it is the manual implementation of \emph{zip}, which just determines what is the
part that we may want to access or update:

\begin{lstlisting}
val zip = Lens[Address, Int](
  s => s.zip,
  (s, a) => s.copy(zip = a))
\end{lstlisting}

Now, it is time for us to distill the algebraic essence of a lens, since we are
interested on taking its interface to new settings. To do so, we need to view
this abstraction from a coalgebraic perspective~\cite{jacobs1995objects,
jacobs1997tutorial}. Particularly, coalgebras can be seen as machines with
buttons to forward its current state. These buttons are special, since they
could require an input to be pressed or they could produce an output to the
environment. The following process turns the original lens operations into
state-based transformations were buttons are made explicit.

\begin{lemma}
  Let $s_0, s_1 \in S$ and $a_0, a_1 \in A$. If we consider a very well behaved
  lens (\emph{get}, \emph{set}) with whole $S$ and focus $A$, where $s_0$ and
  $s_1$ enclose $a_0$ and $a_1$, respectively
  \begin{align*}
    &  (get, set) \\
    &=\ (s_0 \Rightarrow a_0,\ (s_0,\ a_1) \Rightarrow s_1) &&\text{(expand methods)} \\
    &=\ (s_0 \Rightarrow a_0,\ (a_1,\ s_0) \Rightarrow s_1) &&\text{(flip \emph{set} arguments)} \\
    &=\ (s_0 \Rightarrow a_0,\ a_1 \Rightarrow s_0 \Rightarrow s_1) &&\text{(curry \emph{set})} \\
    &=\ (() \Rightarrow s_0 \Rightarrow a_0,\ a_1 \Rightarrow s_0 \Rightarrow s_1) &&\text{(input for \emph{get})} \\
    &=\ (() \Rightarrow s_0 \Rightarrow a_0,\ a_1 \Rightarrow s_0 \Rightarrow (s_1,\ ())) &&\text{(output for \emph{set})} \\
    &=\ (() \Rightarrow s_0 \Rightarrow (s_0,\ a_0),\ a_1 \Rightarrow s_0 \Rightarrow (s_1,\ ())) &&\text{(resulting state for \emph{get})} \\
    &=\ (() \Rightarrow State(s_0 \Rightarrow (s_0,\ a_0)),\ a_1 \Rightarrow State(s_0 \Rightarrow (s_1,\ ()))) &&\text{(State wrap)} \\
  \end{align*}
\end{lemma}

% TODO: use button notation from jacobs paper
So, we started with the pair of lens operations and we ended up with a pair of
buttons, each of them showing the notion of input, output and state
transformation. Particularly, to homogenize the button intuition in both
operations, we had to provide an artificial input to \emph{get}, an artificial
output to \emph{set} and an artificial resulting state to \emph{get} ---which
keeps the old state as is. Thereby, we could represent the type that describes
the final buttons in this interface as follows:
\begin{lstlisting}
trait LensButtons[S, A] {
  def get(): State[S, A]
  def set(a: A): State[S, Unit]
}
\end{lstlisting}

Despite the fact that we identified the buttons, it is still difficult to see
how to take them to other settings. Indeed, \lstinline{LensButtons} is
completely coupled to in-memory data structures. This is evidenced in the right
hand side of the methods, where we can find plain \lstinline{State} programs. If
we aim at being more generic, we should abstract away any reference to
\lstinline{State[S, ?]} from the buttons.

\begin{definition}
A lens algebra is a multi-parameter typeclass that is indexed over two type
parameters \lstinline{F[_]} and \lstinline{A} and which defines a pair of
methods \lstinline{get} and \lstinline{set}.
\begin{lstlisting}
trait LensAlg[F[_], A] {
  def get(): F[A]
  def set(a: A): F[Unit]
}
\end{lstlisting}
\end{definition}

Informally, we can see that \lstinline{F} is representing a state-based effect,
which let us access or update a value typed \lstinline{A} ---which is somehow
contextualized in \lstinline{F}--- by means of \lstinline{get} and
\lstinline{set}.

\begin{remark}

We can recover \lstinline{LensButtons} by instancing \lstinline{LensAlg} for
\lstinline{State[S, ?]}

\begin{lstlisting}
type LensButtons[S, A] = LensAlg[State[S, ?], A]
\end{lstlisting}

\end{remark}

Most of typeclasses require laws to be useful, and \lstinline{LensAlg} is not an
exception for that. Since the original lens holds several properties, we could
infer that \lstinline{LensAlg} laws will be related to them somehow. Take lens
\emph{GetPut} law as an example. It establishes that getting the part and then
setting it again does not produce an overall effect. It is now tempting to think
that \lstinline{LensAlg} should behave accordingly. However, \lstinline{get}
returns a value typed \lstinline{F[A]}, which cannot be fed to \lstinline{set}.

Monad is the combinator that we need to recover lens laws in
\lstinline{LensAlg}. If \lstinline{F} is an instance of monad, we can establish
the analogous \emph{GetPut} for \lstinline{LensAlg} as follows:
\begin{align*}
  & get\ >>=\ set\ =\ return\ () &&\textbf{GetPut}
\end{align*}
We can represent the other laws using monadic analogous as well. In addition, we
need to include a new law, which emerges when we represent \lstinline{get} as a
stateful computation. This new law tells us that this method cannot modify the
machine state, since it is a mere observer. This typeclass, laws included,
should be familiar to a functional programmer.

\begin{corollary}
If you distill the algebraic essence of a lens, you get \lstinline{MonadState}
(laws included).
\end{corollary}

We, as programmers, are used to work with the instance
\lstinline{MonadState[State[S, ?], S]}, where the value behind \lstinline{State}
is precisely the value that you have access to from the typeclass methods.
However, we gave a different intuition for lens algebras, where we exhibited the
instance \lstinline{LensAlg[State[S, ?],A]}, where \lstinline{A} is somehow
contextualized in \lstinline{S}. Surprinsingly, in order to implement such an
instance, we are going to need a \lstinline{Lens[S, A]}. In fact, there are many
interesting connections between lenses and state
computations~\cite{abou2015notions}.

Now, we could use lens algebras to represent \emph{address}, from the
example of the introduction. Concretely, we could express it as a pair of lens
algebras, one of them granting access to the city and the other one doing the
proper for the zip code, as follows: % TODO: idealized Scala? Applicative
\begin{lstlisting}
trait Address[Q[_]: Applicative] {
  def city: LensAlg[Q, String]
  def zip:  LensAlg[Q, Int]

  def serialize: Q[String] = (city.get |@| zip.get) { (c, z) =>
    s'{ "city":$c, "zip":$z }'
  }
}
\end{lstlisting}
As you can see, \lstinline{Address} is itself a typeclass. It is defined for
every \lstinline{F}, as long as we can provide the pair of lens algebras
\lstinline{city} and \lstinline{zip} for it. The intuition is that \lstinline{Q}
is somehow hiding the means to manipulate the state of the address.

The major benefit that we get by adopting this pattern is that we can implement
the business logic once and for all, exploiting the same algebra that we use
when dealing with normal lenses. This is evidenced in \lstinline{serialize},
which returns a program that invokes \lstinline{get} to collect and serialize
the involved values.

We saw that optic composition is a key feature to cope with nested data
structures. In the next section, we will cover composability at this high level
of abstraction enabled by lens algebras.

\section{Natural lens algebras}
\label{sec:Natural}

A particular lens is not very useful by itself, but it becomes extremely handy
in combination with other lenses. Since concrete lenses do not compose well,
there has been great interest on discovering new lens representations ---such
as \emph{van laarhoven} or \emph{profunctor}--- to improve this
feature~\cite{pickering2017profunctor}. In fact, these representations compose
nicely, because they are essentially functions.

There is another function-like representation for lenses which is not so
widespread in the folklore~\cite{abou2015notions}. It consists of a particular
monad morphism\footnote{We use \emph{kind-projector} to dulcify the morphism
types}:
\begin{lstlisting}
type Lens[S, A] = State[A, ?] ~> State[S, ?]
\end{lstlisting}
Informally, if you have a state program on the focus, you can transform it into
a state program on the whole. As any other homomorphism, this natural
transformation is composable. Thereby, we could compose it with another lens, as
long as its whole matches the focus of the original lens. What is interesting
about this particular representation is that a state program produces an output
value along with the state transformation. This idea will serve us well later.

As expected, we are interested on taking composition to optic algebras.
Particularly, we will exploit the last lens representation to do so, but prior
to that, we need to understand what we are referring to when we talk about lens
algebra composition. Using the guiding example, we could define a
\lstinline{person} lens algebra as we did for address in the last section,
aiming at composing their inner lenses:
\begin{lstlisting}
trait Person[P[_]] {
  type Ad
  def address: LensAlg[P, Ad]
}

trait Address[Q[_]] {
  def zip: LensAlg[Q, Int]
}
\end{lstlisting}
So, we get a \lstinline{Person} which is parameterized by \lstinline{P}, the
type of programs that knows how to evolve a person. This trait contains a lens
\lstinline{address}, whose focus is \lstinline{Ad}, we are not sure about the
particular representation for it, so we left it opened. Now, we are interested
on composing it with \lstinline{zip}, as we did previously with concrete lenses.
To recap, there is \lstinline{zip} lens, which produces programs \lstinline{Q}
to evolve an address, and there is \lstinline{address} lens, which produces
programs \lstinline{P} to evolve a person. If we want to compose both lenses, we
need to inject \lstinline{Q} programs into \lstinline{P} ones. This sounds a lot
like a natural transformation \lstinline{Q ~> P}.

As a naive approach, we could consider that a monad morphism from \lstinline{Q}
to \lstinline{P} is a nice candidate to be a composable representation for optic
algebras. In fact, \lstinline{Q ~> P} is what we get when we abstract away from
\lstinline{State[A, ?] ~> State[S, ?]}:
\begin{lstlisting}
trait NaiveLensNat[P[_]: Monad, Q[_]: Monad, A] {
  def apply: Q ~> P
}
\end{lstlisting}
However, it is not possible to implement \lstinline{get} and \lstinline{set}
given this monad morphism alone, so it is difficult to establish connections
with the results obtained from section~\ref{sec:Towards}.

To avoid this situation, we need to relate somehow the type constructors
\lstinline{P} and \lstinline{Q} with the focus \lstinline{A}. Indeed, when we
abstract \lstinline{State[A, ?]} from the monad morphism, we can determine not
only that \lstinline{Q} is a monad but also that it is a \lstinline{MonadState}
for \lstinline{A}. It appears that if we add this new constraint to our monad
morphism, we are able to implement \lstinline{get} and \lstinline{set}, feeding
the corresponding programs to the homomorphism:

\begin{definition}

The natural representation of a lens algebra is a monad morphism which is lifted
into a monad state morphism from \lstinline{Q} ---the inner program that evolves
the part--- to \lstinline{P} ---the outer program that evolves the whole.

\begin{lstlisting}
trait LensNat[P[_]: Monad, Q[_]: MonadState[A, ?[_]], A]
    extends LensAlg[P, A] { self =>

  def apply: Q ~> P

  def get: P[A] = apply(MS.get)
  def set(a: A): P[Unit] = apply(MS.put(a))
}
\end{lstlisting}

\end{definition}

By implementing \lstinline{get} and \lstinline{set} this way, we are actually
forcing the monad morphism to be a \emph{monad state morphism}. In other words,
we are turning \lstinline{Q} ---a program that evolves the focus
\lstinline{A}--- into \lstinline{P} ---a program that evolves the whole (hidden
by \lstinline{P})--- but the morphism preserves \lstinline{get} and
\lstinline{set}, so we grant access to \lstinline{A} in terms of \lstinline{P}
programs.

The gretatest benefit we get by using \lstinline{LensNat} is that it enables
lens algebra composition. Next, we show the corresponding method to achieve such
task:
\begin{lstlisting}
def compose[R[_], B](other: LensNat[Q, R, B]): LensNat[P, R, B] =
  new LensNat[P, R, B] {
    def apply: R ~> P = self.apply compose other.apply
  }
\end{lstlisting}

This tells us that if we compose a lens \lstinline{ln1: LensNat[P, Q, A]} with
another lens \lstinline{ln2: LensNat[Q, R, B]} we get a new lens algebra typed
\lstinline{LensNat[P, R, B]}. To put it in another way, if the inner program of
\lstinline{ln1} matches the outer program of \lstinline{ln2} we can define a new
lens algebra whose inner program focuses in a more specific part of the state.

Now we should be able to compose \lstinline{address} with \lstinline{zip}. To do
so, we need to establish a connection between the inner program from
\lstinline{address} and the outer program from \lstinline{zip}. We could do so
using the next pattern:
\begin{lstlisting}
trait Person[P[_]] {
  type Ad
  type Q[_]: Address
  def address: LensNat[P, Q, Ad]
}

trait Address[Q[_]] {
  def zip: LensNat[Q, State[Int, ?], Int]
}
\end{lstlisting}
Notice that we had to specify that \lstinline{Q} instantiates the
\lstinline{Address} typeclass to connect \lstinline{address} inner program with
\lstinline{zip} outer one. On the other hand, the inner program for
\lstinline{zip} is concrete, since we are not interested on further composing
this particular lens algebra.

Once we have defined the basic data layer in general terms, we can use it to
implement the application logic. In this particular scenario, we could be
interested on modifying the zip code associated to a person:
\begin{lstlisting}
def modZip[P[_]](f: Int => Int)(p: Person[P]): P[Unit] = {
  import p.address, p.Address.zip
  (address compose zip).modify(f)
}
\end{lstlisting}
As you can see, the implementation is completely decoupled from any
infrastructure. It no longer works for a specific case class, but for any type
\lstinline{P} that qualifies a \lstinline{Person}. And, still, what is great
here is that this implementation is almost the same as the one we did for the
in-memory scenario in section~\ref{sec:Introduction}.

\section{Generalizing to other optics}
\label{sec:Generalizing}

Lens composition is fundamental to deal with nested data structures, but optics
really shine when they are composed
heterogeneously~\cite{pickering2017profunctor}. Therefore, in order to take
optic benefits to the algebraic setting, we need to describe other optic
algebras and be able to compose them. In this section, we introduce \emph{affine
algebras} and \emph{traversal algebras}. For each of them, we will show a very
brief introduction, we will extract its algebraic essence and finally, we will
show a composable representation.

\subsection{Affine Algebra}

A lens implies that the part is always present in the whole, however this could
not be the case in other scenarios. Affine\footnote{This optic is also known as
\emph{affine traversal}, \emph{affine lens} or even \emph{optional} in the
folklore.} comes to alleviate this situation by evidencing that the part could
be unavailable from the whole:

\begin{lstlisting}
case class Affine[S, A](
  getOption: S => Option[A],
  set: (S, A) => S)
\end{lstlisting}

If we derive the essence of the affine, as we did in section~\ref{sec:Towards}
for lens, we end up with the following definition for affine algebras:

\begin{lstlisting}
trait AffineAlg[F[_], A] extends Monad[F] {
  def getOption(): F[Option[A]]
  def set(a: A): F[Unit]
}
\end{lstlisting}

As for the lens algebra case, it does not make much sense to compose affine
algebras. We need to find a morphism representation to enable this feature.
Intuitively, an inner program that modifies the part should be transformed into
an outer program that optionally modifies the whole, just in case the part does
exist. This intuition lead us to the following representation:

\begin{lstlisting}
case class NatAffineAlg[P[_], Q[_], A](
    hom: Q ~> P[Option[?]])(implicit
    MS: MonadState[A, Q]) extends AffineAlg[P, A] {
  def getOption(): P[Option[A]] = hom(MS.get)
  def put(a: A): P[Option[Unit]] = hom(MS.put(a))
}
\end{lstlisting}

In fact, if we instantiate this algebra for
\lstinline{NatAffineAlg[State[S, ?], State[A, ?], A]} we get something
isomorphic to \lstinline{Affine[S, A]}, which supports the new algebra
definition. Now that we have a composable representation, we should be able to
compose a pair of affine algebras:

\begin{lstlisting}
def compose[P[_], Q[_], R[_], B](
    af1: NatAffineAlg[P, Q, A]
    af2: NatAffineAlg[Q, R, B])(implicit
    MS1: MonadState[A, Q],
    MS2: MonadState[B, R]): NatAffineAlg[P, R, B] =
  NatAffineAlg((af1.hom compose af2.hom).map(_.join))
\end{lstlisting}

And what is even more interesting, we should be able to compose optics
heterogeneously, for instance, a lens algebra with an affine algebra:

\begin{lstlisting}
def compose[P[_], Q[_], R[_], B](
    ln: NatLensAlg[P, Q, A]
    af: NatAffineAlg[Q, R, B])(implicit
    MS1: MonadState[A, Q],
    MS2: MonadState[B, R]): NatAffineAlg[P, R, B] =
  NatLensAlg(ln.hom compose af.hom)
\end{lstlisting}

This composition results in an affine algebra, which is pretty consistent with
classic optic composition, where the result of composing a lens with an affine
is itself an affine. Notice as well that reversing the composing optic types,
eg: composing an affine algebra with a lens algebra, does not affect the
resulting type.

\subsection{(Weak) Traversal Algebra}

While lenses and affines do focus on a single part, which could or could not
exist, we lack something to focus on a sequence of parts, which is exactly what
traversals are for. This optic turns out to be tricky and it is not possible to
represent it as a bunch of simple functions~\cite{oconnor2011functor}.
Therefore, we will use a relaxed version, which we call \emph{Weak Traversal}:

\begin{lstlisting}
case class WTraversal[S, A](
  getAll: S => List[A],
  modify: (A => A) => S => S)
\end{lstlisting}

This optic is constrained in the sense that the modification that we achieve
over each part must be exactly the same, but we find it good enough for most of
cases. If we derive the essence of a weak traversal, we get the following
interface:

\begin{lstlisting}
trait WTraversalAlg[F[_], A] extends Monad[F] {
  def getList(): F[List[A]]
  def modify(f: A => A): F[List[Unit]]
}
\end{lstlisting}

As usual, we need to find a composable representation for these traversal
algebras. If we apply the same ideas that we used for affine algebras, we get
the next representation, where the possibility of failing focus is replaced with
the possibility of multiple focus:

\begin{lstlisting}
case class NatWTraversalAlg[P[_], Q[_], A](
    hom: Q ~> P[List[?]])(implicit
    MS: MonadState[A, Q]) extends WTraversalAlg[P, A] {
  def getList() = hom(MS.get)
  def modify(f: A => A) = hom(MS.put(a))
}
\end{lstlisting}

Again, if we instantiate this algebra for
\lstinline{NatWTraversalAlg[State[S, ?], State[A, ?], A]} we get something
isomorphic to \lstinline{WTraversal[S, A]}. Now that we have a composable
representation, we should be able to compose homogeneously:

\begin{lstlisting}
def compose[P[_], Q[_], R[_], B](
    af1: NatWTraversalAlg[P, Q, A]
    af2: NatWTraversalAlg[Q, R, B])(implicit
    MS1: MonadState[A, Q],
    MS2: MonadState[B, R]): NatWTraversalAlg[P, R, B] =
  NatWTraversalAlg((af1.hom compose af2.hom).map(_.join))
\end{lstlisting}

And besides, we should be able to compose optics heterogeneously, for instance,
a lens algebra with a traversal algebra:

\begin{lstlisting}
def compose[P[_], Q[_], R[_], B](
    ln: NatLensAlg[P, Q, A]
    af: NatTraversalAlg[Q, R, B])(implicit
    MS1: MonadState[A, Q],
    MS2: MonadState[B, R]): NatTraversalAlg[P, R, B] =
  NatTraversalAlg(ln.hom compose af.hom)
\end{lstlisting}

As expected by optic composition rules, composing lens algebras with traversal
algebras results in traversal algebras. Had we composed with an affine algebra
instead, it would have resulted in a traversal algebra.

\section{Stateless: an optic algebra Scala library}
\label{sec:Stateless}

Once we have introduced the fundamentals of optic algebras, it is time to put
them into practice. In fact, we have implemented Stateless, a Scala library
where we deploy algebras and utilities to deal with them. We will use a guiding
example to introduce the library basics. Particularly, we will extend the
\emph{zip code} one. Now, we will consider that there exists a department, with
a budget and a list of members. For each member, we will be able to access its
name and optionally, to access its address. Each address, in turn, will contain
the associated city and zip code. Our objective is to implement
\lstinline{modifyZip}, that receives a function to modify a zip code and returns
a program that modifies all the zip codes belonging to the people in the
department according to the input function.

Our example contains three major entities: address, person and department. Each
of them will be located in its own data structure. We will start with address,
which contains the name of the city and the zip code itself. Since they appear
exactly once in every address, we know that accessing those fields could be
achieved by means of lenses. Therefore we represent addresses as follow:

\begin{lstlisting}
trait Address[Ad] {
  type P[_]
  val city: LensAlg[P, String]
  val zip: LensAlg[P, Int]
}
\end{lstlisting}

First of all, this trait takes a type parameter that represents the final state
of the address, or the context to get access to it. Secondly, it contains a
\lstinline{type member} which roles programs that are able to access and modify
the address state. Finally, you can find a lens algebras for each field.
Concretely, this is a natural lens algebra. Contrary to what we saw in
section~\ref{sec:Natural}, Stateless use the same name for both raw and natural
optic algebras (which are kept in different packages), and hides the
\lstinline{Q} type parameter as a type member for the second case, to improve
compiler inference while composing optics. Now, we show how to encode a person:

\begin{lstlisting}
trait Person[Pr] {
  type P[_]
  type Ad
  val name: LensAlg[P, String]
  val address: Address[Ad]
  val optAddress: OptionalAlg.Aux[P, address.P, Ad]
}
\end{lstlisting}

As before, this entity takes a type parameter \lstinline{Dp}, which represents
the final state, and a type member \lstinline{P}, which corresponds with the
program that transforms the state. Besides, this entity contains two fields and
therefore they are mapped into two optic algebras. There is nothing remarkable
about \lstinline{name}, but \lstinline{optAddress} brings new patterns.
Specifically, its returning type contemplates \lstinline{Q}, since we need to
connect its inner program with the outer program from \lstinline{Address}, to
make them composable. As a consequence, we need to provide an evidence of entity
\lstinline{address}, and therefore the type of its final state \lstinline{Ad}.
The last entity, department, is represented as folows:

\begin{lstlisting}
trait Department[Dp] {
  type P[_]
  type Pr
  val budget: LensAlg[P, Long]
  val person: Person[Pr]
  val people: TraversalAlg.Aux[P, person.P, Pr]
}
\end{lstlisting}

It contains two optic algebras, a simple lens for \lstinline{budget} and a
dependent traversal for \lstinline{people}. Concretely, it has to establish the
dependency between department and person. To do so, we use the same pattern we
described above for \lstinline{optAddress}.

The resulting data layer does not differ greatly from representing the state of
the application with several case classes. In this sense, a simple field is
represented with a lens algebra, an optional field is represented with an affine
algebra and a list of elements is represented with a traversal algebra.

The most striking feature of this data layer is that we can describe
\lstinline{modifyZip} once and for all, in a modular and elegant way:

\begin{lstlisting}
def modifyZip(f: Int => Int): P[Unit] =
  (people compose optAddress compose zip).modify(f)
\end{lstlisting}

As you see, Stateless contains infix methods to compose a particular optic with
another passed as argument, following the classic optic hierarchy. In this
regard, it also contains abstracting methods, to turn an optic algebra into a
hierarchy ancestor. Finally, it also provides the means to transform an optic
algebra into its corresponding indexed one.

Notice that \lstinline{modifyZip} knows nothing about the particular programs or
the final application state. In fact, they could be mere \emph{State} programs
dealing with case classes as state, or they could be \emph{IO} programs using a
database session as state. We show these particular interpretations in the
appendix. There you will find the utilities that Stateless provides to
facilitate the instantiating task.
% TODO: provide appendix

% Indexed, Lib, etc.

% Future work

\section{Related Work}
\label{sec:Discussion}

\section{Conclusion}

% Weak Algebra, Prism Algebra, etc.

% Ignoring polymorphic STAB

\section*{Acknowledgements}
MINECO

\bibliography{stateless}{}
\bibliographystyle{unsrt}

\end{document}
