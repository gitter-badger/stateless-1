\documentclass[preview, 3p]{elsarticle}

\usepackage{amsmath,amsthm,amssymb}
\usepackage{listings}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{definition}{Definition}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}{Corollary}[theorem]

\def\bibsection{\section*{References}}

\journal{Somewhere to Publish}

\begin{document}

\begin{frontmatter}

\title{Optic Algebras: Beyond In-memory Data Structures}

\author[urjc,habla]{J.~Lopez-Gonzalez\corref{cor1}\fnref{fn1}}
\ead{j.lopezgo@alumnos.urjc.es}

\author[urjc,habla]{J.M.~Serrano}
\ead{j.serrano.hidalgo@urjc.es}

\cortext[cor1]{Corresponding author}

\fntext[fn1]{This is the specimen author footnote.}

\address[urjc]{Universidad Rey Juan Carlos}
\address[habla]{Habla Computing}

\begin{abstract}
Abstract goes here!
\end{abstract}

\end{frontmatter}

\lstset{language=Scala,
        basicstyle=\small,
        literate={~} {$\sim$}{1}}

\newtheorem*{remark}{Remark}

\section{Introduction}
\label{sec:Introduction}

Optics provide abstractions and patterns to access and update immutable data
structures. Specifically, they access and update \emph{focus} values which are
contextualized within a \emph{whole} data structure. There are different kinds
of optics in the
folklore\footnote{http://oleg.fi/gists/images/optics-hierarchy.svg}, each of
them describing a particular type of transformation. Among them, \emph{lens} has
become the most prominent one.

A lens do focus on a unique value that is always available from the whole data
structure. They turn out to be very useful to express transformations over
nested data structures~\cite{foster2005combinators}. As an example, consider the
following Scala classes~\cite{odersky2004overview}, where we use macro
annotations\footnote{This annotation is provided by \emph{Monocle}, the most
relevant optic library in the Scala ecosystem.} to generate a lens for each
field (or focus) of the annotated case class (or whole):

\begin{lstlisting}
@Lenses case class Person(
  name: String,
  address: Address)

@Lenses case class Address(
  city: String,
  zip: Int)
\end{lstlisting}

Now suppose we want to modify the zip code associated to a person. Since lens
composition is closed~\cite{pickering2017profunctor}, we could express that
transformation by combining the lenses associated to \emph{address} and
\emph{zip} fields and then using the resulting one to invoke the modifying
method:

\begin{lstlisting}
def modZip(f: Int => Int): Person => Person =
  (address compose zip).modify(f)
\end{lstlisting}

Despite the elegance that we get to describe this kind of transformations,
lenses are restricted to work exclusively with in-memory data structures.
Imagine that we wanted to persist this person in a relational database using
\emph{Doobie} or \emph{Slick}. In this scenario, we would discard optics in
favor of the specific transformations provided by these technologies. Otherwise,
we would need to pull the whole state, modify it by means of a lens and finally
put it back again, which turns out to be completely impractical.

Firstly, we claim that it is possible to collect the essence of optics in a
domain specific language~\cite{hudak1996building}, aimed to take optic
abstractions and patterns beyond in-memory data structures. Secondly, we claim
that this language is expressive enough to implement the data layer of an
application and its associated logic once and for all, and later instantiate
them to particular state-based interpretations: in-memory data structures,
databases, microservices, etc. Lastly, we claim that we can do so while
retaining reasonable levels of performance for a large class of applications.
These are our contributions to fulfill our claims:

\begin{itemize}

\item We propose \emph{lens algebra} (section \ref{sec:Towards}), which distills
the algebraic essence of a lens. To better illustrate this idea, we need to see
lenses from a coalgebraic perspective~\cite{jacobs1995objects,
jacobs1997tutorial, oconnor2011functor}. In this sense, optics are just machines
---that can possibly run forever~\cite{turner2004total}--- with buttons that can
be pressed to observe or forward the machine state. In fact, what we mean by the
algebraic essence is just the description of the machine interface in terms of
its buttons, where any reference to the inner state has been abstracted away.

\item Lens algebras in their \emph{raw} formulation do not compose. In fact, it
is difficult to determine what we mean by composition at this level of
abstraction. To alleviate the situation, we propose a \emph{natural}
representation (section \ref{sec:Natural}) ---which heavily relies on natural
transformations~\cite{pierce1991basic}--- that enables composition for lens
algebras.

\item We take these ideas to other optics, particularly: \emph{getter},
\emph{setter}, \emph{fold}, \emph{affine} and \emph{weak traversal\footnote{This
is a relaxed traversal, where the transformation function for each focus must be
exactly the same.}}. As a result, we end up with a collection of algebras that
we refer to as \emph{optic algebras} (section \ref{sec:Generalizing}). These
algebras represent analogous transformations to their in-memory optic
counterparts, even preserving heterogeneous composition, but in a more general
setting.

\item We provide \emph{Stateless} (section \ref{sec:Stateless}), an optic
algebra library which is aimed to take these concepts and patterns to the
development of industrial applications in the Scala ecosystem.

\end{itemize}

Previously, when we stated that optic algebras pursue transforming state in
different settings, we actually meant that we want them to support different
state-based effects~\cite{wadler1995monads}. In this sense, there exists work
relating optics and effects, being \emph{monadic
lenses}~\cite{abou2016reflections} the most relevant one. Bidirectional
transformations~\cite{abou2015notions, abou2017coalgebraic} is also a great
source of effectful transformations. We will compare our approach with these
techniques in section \ref{sec:Discussion}.

\section{Towards more abstract lenses}
\label{sec:Towards}

As stated in~\cite{foster2005combinators}, lenses approach the view update
problem for tree-structured data.

\begin{definition}

A \emph{lens} consists of a pair of functions, one of them \emph{gets} the
part from the whole and the other one \emph{sets} a new part into an old whole,
returning a new whole. They are encoded in Scala as
follows~\cite{morris2012asymmetric}:

\begin{lstlisting}
case class Lens[S, A](
  get: S => A,
  set: (S, A) => S)
\end{lstlisting}
As you may figured out, $S$ and $A$ serve as the whole and the part,
respectively. Lens operations must obey certain laws to be considered very
well-behaved~\cite{fischer2015clear}:
\begin{align*}
  & set(s,\ get(s))\ =\ s &&\textbf{GetPut} \\
  & get(set(s,\ a))\ =\ a &&\textbf{PutGet} \\
  & set(set(a1,\ s),\ a2)\ =\ set(s,\ a2) &&\textbf{PutPut}
\end{align*}

\end{definition}

In section \ref{sec:Introduction} we saw that lens generation for the fields of
a case class is systematic, since we generated them automatically. Anyway, here
it is the manual implementation of \emph{zip}, which just determines what is the
part that we may want to access or update:

\begin{lstlisting}
val zip = Lens[Address, Int](
  s => s.zip,
  (s, a) => s.copy(zip = a))
\end{lstlisting}

Now, it is time for us to distill the algebraic essence of a lens, since we are
interested on taking its interface to new settings. To do so, we need to view
this abstraction from a coalgebraic perspective~\cite{jacobs1995objects,
jacobs1997tutorial}. Particularly, coalgebras can be seen as machines with
buttons to forward its current state. These buttons are special, since they
could require an input to be pressed or they could produce an output to the
environment. The following process turns the original lens operations into
state-based transformations were buttons are made explicit.

\begin{lemma}
  Let $s_0, s_1 \in S$ and $a_0, a_1 \in A$. If we consider a very well behaved
  lens (\emph{get}, \emph{set}) with whole $S$ and focus $A$, where $s_0$ and
  $s_1$ enclose $a_0$ and $a_1$, respectively
  \begin{align*}
    &  (get, set) \\
    &=\ (s_0 \Rightarrow a_0,\ (s_0,\ a_1) \Rightarrow s_1) &&\text{(expand methods)} \\
    &=\ (s_0 \Rightarrow a_0,\ (a_1,\ s_0) \Rightarrow s_1) &&\text{(flip \emph{set} arguments)} \\
    &=\ (s_0 \Rightarrow a_0,\ a_1 \Rightarrow s_0 \Rightarrow s_1) &&\text{(curry \emph{set})} \\
    &=\ (() \Rightarrow s_0 \Rightarrow a_0,\ a_1 \Rightarrow s_0 \Rightarrow s_1) &&\text{(input for \emph{get})} \\
    &=\ (() \Rightarrow s_0 \Rightarrow a_0,\ a_1 \Rightarrow s_0 \Rightarrow (s_1,\ ())) &&\text{(output for \emph{set})} \\
    &=\ (() \Rightarrow s_0 \Rightarrow (s_0,\ a_0),\ a_1 \Rightarrow s_0 \Rightarrow (s_1,\ ())) &&\text{(resulting state for \emph{get})} \\
    &=\ (() \Rightarrow State(s_0 \Rightarrow (s_0,\ a_0)),\ a_1 \Rightarrow State(s_0 \Rightarrow (s_1,\ ()))) &&\text{(State wrap)} \\
  \end{align*}
\end{lemma}

% TODO: use button notation from jacobs paper
So, we started with the pair of lens operations and we ended up with a pair of
buttons, each of them showing the notion of input, output and state
transformation. Particularly, to homogenize the button intuition in both
operations, we had to provide an artificial input to \emph{get}, an artificial
output to \emph{set} and an artificial resulting state to \emph{get} ---which
keeps the old state as is. Thereby, we could represent the type that describes
the final buttons in this interface as follows:
\begin{lstlisting}
trait LensButtons[S, A] {
  def get(): State[S, A]
  def set(a: A): State[S, Unit]
}
\end{lstlisting}

Despite the fact that we identified the buttons, it is still difficult to see
how to take them to other settings. Indeed, \lstinline{LensButtons} is
completely coupled to in-memory data structures. This is evidenced in the right
hand side of the methods, where we can find plain \lstinline{State} programs. If
we aim at being more generic, we should abstract away any reference to
\lstinline{State[S, ?]} from the buttons.

\begin{definition}
A lens algebra is a multi-parameter typeclass that is indexed over two type
parameters \lstinline{F[_]} and \lstinline{A} and which defines a pair of
methods \lstinline{get} and \lstinline{set}.
\begin{lstlisting}
trait LensAlg[F[_], A] {
  def get(): F[A]
  def set(a: A): F[Unit]
}
\end{lstlisting}
\end{definition}

Informally, we can see that \lstinline{F} is representing a state-based effect,
which let us access or update a value typed \lstinline{A} ---which is somehow
contextualized in \lstinline{F}--- by means of \lstinline{get} and
\lstinline{set}.

\begin{remark}

We can recover \lstinline{LensButtons} by instancing \lstinline{LensAlg} for
\lstinline{State[S, ?]}

\begin{lstlisting}
type LensButtons[S, A] = LensAlg[State[S, ?], A]
\end{lstlisting}

\end{remark}

Most of typeclasses require laws to be useful, and \lstinline{LensAlg} is not an
exception for that. Since the original lens holds several properties, we could
infer that \lstinline{LensAlg} laws will be related to them somehow. Take lens
\emph{GetPut} law as an example. It establishes that getting the part and then
setting it again does not produce an overall effect. It is now tempting to think
that \lstinline{LensAlg} should behave accordingly. However, \lstinline{get}
returns a value typed \lstinline{F[A]}, which cannot be fed to \lstinline{set}.

Monad is the combinator that we need to recover lens laws in
\lstinline{LensAlg}. If \lstinline{F} is an instance of monad, we can establish
the analogous \emph{GetPut} for \lstinline{LensAlg} as follows:
\begin{align*}
  & get\ >>=\ set\ =\ return\ () &&\textbf{GetPut}
\end{align*}
We can represent the other laws using monadic analogous as well. In addition, we
need to include a new law, which emerges when we represent \lstinline{get} as a
stateful computation. This new law tells us that this method cannot modify the
machine state, since it is a mere observer. This typeclass, laws included,
should be familiar to a functional programmer.

\begin{corollary}
If you distill the algebraic essence of a lens, you get \lstinline{MonadState}
(laws included).
\end{corollary}

We, as programmers, are used to work with the instance
\lstinline{MonadState[State[S, ?], S]}, where the value behind \lstinline{State}
is precisely the value that you have access to from the typeclass methods.
However, we gave a different intuition for lens algebras, where we exhibited the
instance \lstinline{LensAlg[State[S, ?],A]}, where \lstinline{A} is somehow
contextualized in \lstinline{S}. Surprinsingly, in order to implement such an
instance, we are going to need a \lstinline{Lens[S, A]}. In fact, there are many
interesting connections between lenses and state
computations~\cite{abou2015notions}.

Now, we could use lens algebras to represent \emph{address}, from the
example of the introduction. Concretely, we could express it as a pair of lens
algebras, one of them granting access to the city and the other one doing the
proper for the zip code, as follows: % TODO: idealized Scala? Applicative
\begin{lstlisting}
trait Address[F[_]: Applicative] {
  def city: LensAlg[F, String]
  def zip:  LensAlg[F, Int]

  def serialize: F[String] = (city.get |@| zip.get) { (c, z) =>
    s'{ "city":$c, "zip":$z }'
  }
}
\end{lstlisting}
As you can see, \lstinline{Address} is itself a typeclass. It is defined for
every \lstinline{F}, as long as we can provide the pair of lens algebras
\lstinline{city} and \lstinline{zip} for it. The intuition is that \lstinline{F}
is somehow hiding the means to manipulate the state of the address.

The major benefit that we get by adopting this pattern is that we can implement
the business logic once and for all, exploiting the same algebra that we use
when dealing with normal lenses. This is evidenced in \lstinline{serialize},
which returns a program that invokes \lstinline{get} to collect and serialize
the involved values.

We saw that optic composition is a key feature to cope with nested data
structures. In the next section, we will cover composability at this high level
of abstraction enabled by lens algebras.

\section{Natural implementation of lenses}
\label{sec:Natural}

Once our lenses algebras are defined, we could be interested in combining them,
just as plain lenses are combined. However, when we move composition to this
scenario, the situation becomes more complicated. As we saw in the person
example (section~\ref{sec:Introduction}), lenses compose when the focus of the
first lens matches the whole of the second one. However, our optic algebras have
a type constructor $F[?]$ as weird whole and a concrete type $A$ as focus, which
leads to an odd scenario.

Therefore, we need to ask ourselves what does it mean to compose a pair of lens
algebras. To do so, we will suppose that we have defined the corresponding optic
algebras to the optics we described in the person example:

\begin{lstlisting}
def addressAlg: LensAlg[F[_], Address]
def zipAlg: LensAlg[G[_], Int]
\end{lstlisting}

At this point, we do not know much about them, but we may guess from the context
that \lstinline{adressAlg} should be hiding somehow the state of a $Person$
while granting accessors to its $Address$ part, while $zipAlg$ encapsulates an
$Address$, providing accessors to the $Int$ zip code. Therefore, if we compose
$addressAlg$ with $zipAlg$ we should end up with a lens whose type would be
close to \lstinline{LensAlg[F[_], Address]}, i.e. an algebra that hides a person
and put focus on the zip code associated to its address. However, this
composition is not possible, since it requires a morphism \lstinline{G ~> F} to
be implemented.

Unfortunately, we know now that lens algebras do not compose. However, along the
way, we found an interesting clue: we need some kind of morphism to compose
them. This is interesting, since there are further connections between monad
morphisms and lenses~\cite{abou2015notions}. Having said so, we would like to
instantiate lens algebra buttons with a morphism-alike representation, to
restore composition. This morphism should transform programs on the part into
programs on the whole. Following these intuitions, we get the following
abstraction:

\begin{lstlisting}
case class NatLensAlg[P[_], Q[_], A](
    hom: Q ~> P)(implicit
    MS: MonadState[A, Q]) extends LensAlg[P, A] {
  def get(): P[A] = hom(MS.get)
  def put(a: A): P[Unit] = hom(MS.put(a))
}
\end{lstlisting}

\lstinline{NatLensAlg} takes three type parameters. The first of them represents
the outer program, that knows how to access the whole. On the other hand, the
second one, or inner program, knows how to access the focus. The type of the
focus is determined by the third type parameter. This abstraction takes one
value parameter \lstinline{hom}, which corresponds with the monad homomorphism
that enables composition.

However, if we want to instantiate \lstinline{LensAlg}, we need to provide an
implementation for \lstinline{get} and \lstinline{set}. There is no way to
provide such implementations solely with the monad morphism \lstinline{hom}.
Thereby, we need to determine what particular inner programs are the ones that
become \lstinline{get} and \lstinline{set} when passed through the homomorphism.
If we assume that our inner program is an instance of \lstinline{MonadState[A, ?]},
this is the same as providing a homomorphism for that algebra among
\lstinline{Q} and \lstinline{P}.

Now, we can declare a method to compose natural lens algebras. Indeed, it
becomes trivial when using this representation, we simply compose monad
morphisms:

\begin{lstlisting}
def compose[P[_], Q[_], R[_], B](
    ln1: NatLensAlg[P, Q, A]
    ln2: NatLensAlg[Q, R, B])(implicit
    MS1: MonadState[A, Q],
    MS2: MonadState[B, R]): NatLensAlg[P, R, B] =
  NatLensAlg(ln1.hom compose ln2.hom)
\end{lstlisting}

Coming back to the guiding person example, we can reformulate our original
lenses as natural lens algebras and compose them:

\begin{lstlisting}
def addressNat: NatLensAlg[F[_], Address]
def zipNat: NatLensAlg[G[_], Int]
def compNat: NatLensAlg[F[_], Int] =
  addressNat compose zipNat
\end{lstlisting}

Notice that we are still working at a high level of abstraction. In fact, we
have no idea about how are \lstinline{F[_]} or \lstinline{G[_]} handling their
encapsulated state. As long as \lstinline{hom} is a monad morphism, our composed
lens expresses that we can access or update the nested part from the whole, no
matter the particular configuration where it is deployed.

\section{Generalizing to other optics}
\label{sec:Generalizing}

Lens composition is fundamental to deal with nested data structures, but optics
really shine when they are composed
heterogeneously~\cite{pickering2017profunctor}. Therefore, in order to take
optic benefits to the algebraic setting, we need to describe other optic
algebras and be able to compose them. In this section, we introduce \emph{affine
algebras} and \emph{traversal algebras}. For each of them, we will show a very
brief introduction, we will extract its algebraic essence and finally, we will
show a composable representation.

\subsection{Affine Algebra}

A lens implies that the part is always present in the whole, however this could
not be the case in other scenarios. Affine\footnote{This optic is also known as
\emph{affine traversal}, \emph{affine lens} or even \emph{optional} in the
folklore.} comes to alleviate this situation by evidencing that the part could
be unavailable from the whole:

\begin{lstlisting}
case class Affine[S, A](
  getOption: S => Option[A],
  set: (S, A) => S)
\end{lstlisting}

If we derive the essence of the affine, as we did in section~\ref{sec:Towards}
for lens, we end up with the following definition for affine algebras:

\begin{lstlisting}
trait AffineAlg[F[_], A] extends Monad[F] {
  def getOption(): F[Option[A]]
  def set(a: A): F[Unit]
}
\end{lstlisting}

As for the lens algebra case, it does not make much sense to compose affine
algebras. We need to find a morphism representation to enable this feature.
Intuitively, an inner program that modifies the part should be transformed into
an outer program that optionally modifies the whole, just in case the part does
exist. This intuition lead us to the following representation:

\begin{lstlisting}
case class NatAffineAlg[P[_], Q[_], A](
    hom: Q ~> P[Option[?]])(implicit
    MS: MonadState[A, Q]) extends AffineAlg[P, A] {
  def getOption(): P[Option[A]] = hom(MS.get)
  def put(a: A): P[Option[Unit]] = hom(MS.put(a))
}
\end{lstlisting}

In fact, if we instantiate this algebra for
\lstinline{NatAffineAlg[State[S, ?], State[A, ?], A]} we get something
isomorphic to \lstinline{Affine[S, A]}, which supports the new algebra
definition. Now that we have a composable representation, we should be able to
compose a pair of affine algebras:

\begin{lstlisting}
def compose[P[_], Q[_], R[_], B](
    af1: NatAffineAlg[P, Q, A]
    af2: NatAffineAlg[Q, R, B])(implicit
    MS1: MonadState[A, Q],
    MS2: MonadState[B, R]): NatAffineAlg[P, R, B] =
  NatAffineAlg((af1.hom compose af2.hom).map(_.join))
\end{lstlisting}

And what is even more interesting, we should be able to compose optics
heterogeneously, for instance, a lens algebra with an affine algebra:

\begin{lstlisting}
def compose[P[_], Q[_], R[_], B](
    ln: NatLensAlg[P, Q, A]
    af: NatAffineAlg[Q, R, B])(implicit
    MS1: MonadState[A, Q],
    MS2: MonadState[B, R]): NatAffineAlg[P, R, B] =
  NatLensAlg(ln.hom compose af.hom)
\end{lstlisting}

This composition results in an affine algebra, which is pretty consistent with
classic optic composition, where the result of composing a lens with an affine
is itself an affine. Notice as well that reversing the composing optic types,
eg: composing an affine algebra with a lens algebra, does not affect the
resulting type.

\subsection{(Weak) Traversal Algebra}

While lenses and affines do focus on a single part, which could or could not
exist, we lack something to focus on a sequence of parts, which is exactly what
traversals are for. This optic turns out to be tricky and it is not possible to
represent it as a bunch of simple functions~\cite{oconnor2011functor}.
Therefore, we will use a relaxed version, which we call \emph{Weak Traversal}:

\begin{lstlisting}
case class WTraversal[S, A](
  getAll: S => List[A],
  modify: (A => A) => S => S)
\end{lstlisting}

This optic is constrained in the sense that the modification that we achieve
over each part must be exactly the same, but we find it good enough for most of
cases. If we derive the essence of a weak traversal, we get the following
interface:

\begin{lstlisting}
trait WTraversalAlg[F[_], A] extends Monad[F] {
  def getList(): F[List[A]]
  def modify(f: A => A): F[List[Unit]]
}
\end{lstlisting}

As usual, we need to find a composable representation for these traversal
algebras. If we apply the same ideas that we used for affine algebras, we get
the next representation, where the possibility of failing focus is replaced with
the possibility of multiple focus:

\begin{lstlisting}
case class NatWTraversalAlg[P[_], Q[_], A](
    hom: Q ~> P[List[?]])(implicit
    MS: MonadState[A, Q]) extends WTraversalAlg[P, A] {
  def getList() = hom(MS.get)
  def modify(f: A => A) = hom(MS.put(a))
}
\end{lstlisting}

Again, if we instantiate this algebra for
\lstinline{NatWTraversalAlg[State[S, ?], State[A, ?], A]} we get something
isomorphic to \lstinline{WTraversal[S, A]}. Now that we have a composable
representation, we should be able to compose homogeneously:

\begin{lstlisting}
def compose[P[_], Q[_], R[_], B](
    af1: NatWTraversalAlg[P, Q, A]
    af2: NatWTraversalAlg[Q, R, B])(implicit
    MS1: MonadState[A, Q],
    MS2: MonadState[B, R]): NatWTraversalAlg[P, R, B] =
  NatWTraversalAlg((af1.hom compose af2.hom).map(_.join))
\end{lstlisting}

And besides, we should be able to compose optics heterogeneously, for instance,
a lens algebra with a traversal algebra:

\begin{lstlisting}
def compose[P[_], Q[_], R[_], B](
    ln: NatLensAlg[P, Q, A]
    af: NatTraversalAlg[Q, R, B])(implicit
    MS1: MonadState[A, Q],
    MS2: MonadState[B, R]): NatTraversalAlg[P, R, B] =
  NatTraversalAlg(ln.hom compose af.hom)
\end{lstlisting}

As expected by optic composition rules, composing lens algebras with traversal
algebras results in traversal algebras. Had we composed with an affine algebra
instead, it would have resulted in a traversal algebra.

\section{Stateless: an optic algebra Scala library}
\label{sec:Stateless}

Once we have introduced the fundamentals of optic algebras, it is time to put
them into practice. In fact, we have implemented Stateless, a Scala library
where we deploy algebras and utilities to deal with them. We will use a guiding
example to introduce the library basics. Particularly, we will extend the
\emph{zip code} one. Now, we will consider that there exists a department, with
a budget and a list of members. For each member, we will be able to access its
name and optionally, to access its address. Each address, in turn, will contain
the associated city and zip code. Our objective is to implement
\lstinline{modifyZip}, that receives a function to modify a zip code and returns
a program that modifies all the zip codes belonging to the people in the
department according to the input function.

Our example contains three major entities: address, person and department. Each
of them will be located in its own data structure. We will start with address,
which contains the name of the city and the zip code itself. Since they appear
exactly once in every address, we know that accessing those fields could be
achieved by means of lenses. Therefore we represent addresses as follow:

\begin{lstlisting}
trait Address[Ad] {
  type P[_]
  val city: LensAlg[P, String]
  val zip: LensAlg[P, Int]
}
\end{lstlisting}

First of all, this trait takes a type parameter that represents the final state
of the address, or the context to get access to it. Secondly, it contains a
\lstinline{type member} which roles programs that are able to access and modify
the address state. Finally, you can find a lens algebras for each field.
Concretely, this is a natural lens algebra. Contrary to what we saw in
section~\ref{sec:Natural}, Stateless use the same name for both raw and natural
optic algebras (which are kept in different packages), and hides the
\lstinline{Q} type parameter as a type member for the second case, to improve
compiler inference while composing optics. Now, we show how to encode a person:

\begin{lstlisting}
trait Person[Pr] {
  type P[_]
  type Ad
  val name: LensAlg[P, String]
  val address: Address[Ad]
  val optAddress: OptionalAlg.Aux[P, address.P, Ad]
}
\end{lstlisting}

As before, this entity takes a type parameter \lstinline{Dp}, which represents
the final state, and a type member \lstinline{P}, which corresponds with the
program that transforms the state. Besides, this entity contains two fields and
therefore they are mapped into two optic algebras. There is nothing remarkable
about \lstinline{name}, but \lstinline{optAddress} brings new patterns.
Specifically, its returning type contemplates \lstinline{Q}, since we need to
connect its inner program with the outer program from \lstinline{Address}, to
make them composable. As a consequence, we need to provide an evidence of entity
\lstinline{address}, and therefore the type of its final state \lstinline{Ad}.
The last entity, department, is represented as folows:

\begin{lstlisting}
trait Department[Dp] {
  type P[_]
  type Pr
  val budget: LensAlg[P, Long]
  val person: Person[Pr]
  val people: TraversalAlg.Aux[P, person.P, Pr]
}
\end{lstlisting}

It contains two optic algebras, a simple lens for \lstinline{budget} and a
dependent traversal for \lstinline{people}. Concretely, it has to establish the
dependency between department and person. To do so, we use the same pattern we
described above for \lstinline{optAddress}.

The resulting data layer does not differ greatly from representing the state of
the application with several case classes. In this sense, a simple field is
represented with a lens algebra, an optional field is represented with an affine
algebra and a list of elements is represented with a traversal algebra.

The most striking feature of this data layer is that we can describe
\lstinline{modifyZip} once and for all, in a modular and elegant way:

\begin{lstlisting}
def modifyZip(f: Int => Int): P[Unit] =
  (people compose optAddress compose zip).modify(f)
\end{lstlisting}

As you see, Stateless contains infix methods to compose a particular optic with
another passed as argument, following the classic optic hierarchy. In this
regard, it also contains abstracting methods, to turn an optic algebra into a
hierarchy ancestor. Finally, it also provides the means to transform an optic
algebra into its corresponding indexed one.

Notice that \lstinline{modifyZip} knows nothing about the particular programs or
the final application state. In fact, they could be mere \emph{State} programs
dealing with case classes as state, or they could be \emph{IO} programs using a
database session as state. We show these particular interpretations in the
appendix. There you will find the utilities that Stateless provides to
facilitate the instantiating task.
% TODO: provide appendix

% Indexed, Lib, etc.

% Future work

\section{Related Work}
\label{sec:Discussion}

\section{Conclusion}

% Weak Algebra, Prism Algebra, etc.

% Ignoring polymorphic STAB

\section*{Acknowledgements}
MINECO

\bibliography{stateless}{}
\bibliographystyle{unsrt}

\end{document}
