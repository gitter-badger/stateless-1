\documentclass[final, twocolumn, 3p]{elsarticle}

\usepackage{amsmath,amsthm,amssymb}
\usepackage{listings}

\def\bibsection{\section*{References}}

\journal{Lambda Days 2018}

\begin{document}

\begin{frontmatter}

\title{Optic Algebras: Beyond In-memory Data Structures}

\author[urjc,habla]{J.~Lopez-Gonzalez\corref{cor1}\fnref{fn1}}
\ead{j.lopezgo@alumnos.urjc.es}

\author[urjc,habla]{J.M.~Serrano}
\ead{j.serrano.hidalgo@urjc.es}

\cortext[cor1]{Corresponding author}

\fntext[fn1]{This is the specimen author footnote.}

\address[urjc]{Universidad Rey Juan Carlos}
\address[habla]{Habla Computing}

\begin{abstract}
Abstract goes here!
\end{abstract}

\end{frontmatter}

\lstset{language=Scala,
        basicstyle=\small,
        literate={~} {$\sim$}{1}}

\newtheorem*{remark}{Remark}

\section{Introduction}
\label{sec:Introduction}

Optics provide abstractions and patterns to access and update immutable
in-memory data structures. Specifically, they access and update \emph{focus}
values which are contextualized within a \emph{whole} data structure. There are
different kinds of optics in the
folklore\footnote{http://oleg.fi/gists/images/optics-hierarchy.svg}, each of
them describing a particular type of transformation. Among them,
\emph{lens}~\cite{foster2005combinators} has become the most prominent one.

A lens do focus on a unique value that is always available from the whole data
structure. They turn out to be very useful to deal with nested data
structures~\cite{morris2012asymmetric}. As an example, consider the following
entities, where \emph{@Lenses} generates a lens for each field (or focus) in
the annotated case class (or whole):

\begin{lstlisting}
@Lenses case class Person(
  name: String,
  address: Address)

@Lenses case class Address(
  city: String,
  zip: Int)
\end{lstlisting}

Now suppose that we want to modify the zip code associated to a person. Since
lenses composition is closed~\cite{pickering2017profunctor}, we could express
that transformation by combining the lenses associated to \emph{address} and
\emph{zip} fields and then using the resulting composed lens to invoke the
modifying method:

\begin{lstlisting}
def modZip(f: Int => Int): Person => Person =
  (address compose zip).modify(f)
\end{lstlisting}

Despite the elegance that we get to describe this kind of transformations,
lenses are restricted to work exclusively with in-memory data structures.
Imagine that we wanted to persist this person in a relational database. In this
scenario, we would discard optics in favor of the specific transformations
provided by the new technology. Otherwise, we would need to pull the whole
state, modify it by means of a lens and finally put it back again, which turns
out to be completely impractical.

Firstly, we claim that it is possible to collect the essence of optics in a
domain specific language~\cite{hudak1996building}, aimed to take optic
abstractions and patterns beyond in-memory data structures. Secondly, we claim
that this language is expressive enough to implement the data layer of an
application and its associated logic once and for all, and later instantiate
them to particular state-based interpretations: in-memory data structures,
databases, microservices, etc. Lastly, we claim that we can do so while
retaining reasonable levels of performance for a large class of applications.
These are our contributions to fulfill our claims:

\begin{itemize}

\item We propose \emph{lens algebra} (section \ref{sec:Towards}), which distills
the algebraic essence of a lens. To better illustrate this idea, we need to see
lenses from a coalgebraic perspective~\cite{jacobs1995objects,
jacobs1997tutorial, oconnor2011functor}. In this sense, optics are just machines
---that can possibly run forever~\cite{turner2004total}--- with buttons that can
be pressed to observe or forward the machine state. In fact, what we mean by the
algebraic essence is just the description of the machine interface in terms of
its buttons, where any reference to the inner state has been abstracted away.

\item Lens algebras in their \emph{raw} formulation do not compose. In fact, it
is difficult to determine what we mean by composition at this level of
abstraction. To alleviate the situation, we propose a \emph{natural}
representation (section \ref{sec:Natural}) ---which heavily relies on natural
transformations~\cite{pierce1991basic}--- that enables composition for lens
algebras.

\item We take these ideas to other optics, particularly: \emph{getter},
\emph{setter}, \emph{fold}, \emph{affine} and \emph{weak traversal\footnote{This
is a relaxed traversal, where the transformation function for each focus must be
exactly the same.}}. As a result, we end up with a collection of algebras that
we refer to as \emph{optic algebras} (section \ref{sec:Generalizing}). These
algebras represent analogous transformations to their in-memory optic
counterparts, even preserving heterogeneous composition, but in a more general
setting.

\item We provide \emph{Stateless} (section \ref{sec:Stateless}), an optic
algebra library which is aimed to take these concepts and patterns to the
development of industrial applications in the Scala ecosystem.

\end{itemize}

Previously, when we stated that optic algebras pursue transforming state in
different settings, we actually meant that we want them to support different
state-based effects~\cite{wadler1995monads}. In this sense, there exists work
relating optics and effects, being \emph{monadic
lenses}~\cite{abou2016reflections} the most relevant one. Bidirectional
transformations~\cite{abou2015notions, abou2017coalgebraic} is also a great
source of effectful transformations. We will compare our approach with these
techniques in section \ref{sec:Discussion}.

\section{Towards more abstract lenses}
\label{sec:Towards}

As stated in~\cite{foster2005combinators}, lenses approach the view update
problem for tree-structured data. They consist of a pair of functions, one of
them to \emph{get} the part from the whole and another one to \emph{set} a new
part into the current whole, returning a new version for the whole. We represent
concrete lenses in Scala ~\cite{morris2012asymmetric} as follows:

\begin{lstlisting}
case class Lens[S, A](
  get: S => A,
  set: (S, A) => S)
\end{lstlisting}

As you may figured out, $S$ and $A$ role the whole and the part, respectively.
Lens operations must obey certain laws to be considered very
well-behaved~\cite{fischer2015clear}. Broadly, they keep the consistency between
$get$ and $set$ and check that $set$ does not modify anything else beyond the
part. We show them below:
\begin{align*}
  & set(s,\ get(s))\ =\ s &&\textbf{GetPut} \\
  & get(set(s,\ a))\ =\ a &&\textbf{PutGet} \\
  & set(set(a1,\ s),\ a2)\ =\ set(s,\ a2) &&\textbf{PutPut}
\end{align*}

In section \ref{sec:Introduction} we inferred that lens generation for the
fields of a case class is systematic, since we could generate them
automatically. As an example, here it is the manual implementation of
\emph{zip}, which just determines where is the part that we may want to access
or update:

\begin{lstlisting}
val zip = Lens[Address, Int](
  s => s.zip,
  (s, a) => s.copy(zip = a))
\end{lstlisting}

Now, it is time for us to distill lenses and extract their algebraic essence.
This consists of abstracting the in-memory details away, in other words,
removing any reference to the outer $S$ state from the pair of functions $get$
and $set$. To do so, we will try to represent both operations in terms of a
state transformation $State[S,\ ?]$, where $S$ is completely isolated, and
therefore easier to abstract away.

State transformations take an initial state and additional input, to produce the
new version of the state along with some output. What follows is an informal
adaptation of the original $get$ and $set$ signatures into this state
transformation template.

\begin{remark}
  Let $s, a$ be types representing the whole and the focus of a lens,
  respectively. So,
  \begin{align*}
    &  (get, set) \\
    &=\ (S \Rightarrow A,\ (S,\ A) \Rightarrow S) &&\text{(a)} \\
    &=\ (S \Rightarrow A,\ (A,\ S) \Rightarrow S) &&\text{(b)} \\
    &=\ (S \Rightarrow A,\ A \Rightarrow S \Rightarrow S) &&\text{(c)} \\
    &=\ (1 \Rightarrow S \Rightarrow A,\ A \Rightarrow S \Rightarrow S) &&\text{(d)} \\
    &=\ (1 \Rightarrow S \Rightarrow A,\ A \Rightarrow S \Rightarrow (S,\ 1)) &&\text{(e)} \\
    &=\ (1 \Rightarrow S \Rightarrow (S,\ A),\ A \Rightarrow S \Rightarrow (S,\ 1)) &&\text{(f*)} \\
    &=\ (1 \Rightarrow State[S,\ A],\ A \Rightarrow State[S,\ 1]) &&\text{(g)} \\
    &\therefore\ (1 \Rightarrow F[A],\ A \Rightarrow F[1]) &&\text{(h*)}\qedhere
  \end{align*}
\end{remark}

So, we start from the original signatures of our $get$ and $set$ operations
packed in a tuple (a). After swapping the arguments (b) and currying (c) from
$set$, we provide an artificial input argument for $get$ (d) typed $1$. On the
other hand, $set$ is lacking the corresponding output, which is added in (e).

The next step consists of providing an artificial transformed output for $get$
(f). We know that this method does not update the state, so this change of
signature comes with a new law\footnote{Steps marked with an asterisk represent
that additional laws emerge.}: the initial state must be placed as the
transformed one as is.
\begin{align*}
  & get_f(s).\_1\ =\ s &&\textbf{XGet} \\
\end{align*}

Finally, once we have our signatures matching the state transformation template,
we can describe them in terms of $State[S,\ ?]$, which is the only place where
we reference $S$ in both operations (g). Now, we can abstract away this
reference to $S$ by turning $State[S,\ ?]$ into a mere $F[?]$ (h). As you might
noticed, this step does not come for free, it requires us to include new laws.
We will come back to this aspect shortly. By now, we can see that the essence of
a lens is precisely a lens algebra. We now package $get_h$ and $set_h$ in a
\emph{trait} to reify this concept:

\begin{lstlisting}
trait LensAlg[F[_], A] {
  def get(): F[A]
  def set(a: A): F[Unit]
}
\end{lstlisting}

If we take into account that typeclasses~\cite{wadler1989make} in Scala are
modeled as traits~\cite{oliveira2010type}, we can appreciate that this class is
basically \emph{MonadState}~\cite{gibbons2012unifying}. The major structural
difference relies in the fact that our class does not extend $Monad$. To go
further with this connection, we need to bring laws into the picture.

The final step of the derivation led us to $get_j$ and $set_j$, that no longer
returned plain types. Instead, their codomain is wrapped with a type constructor
in both cases. Once we carry out this step, lens laws become broken. Take
\textbf{GetSet} as an example, we cannot feed the codomain of $get_j$ to
$set_j$, since it is expecting an $A$ typed argument.

If we want to recover lens laws, we are going to need additional combinators.
These combinators are precisely the ones that we get when $LensAlg$ extends
$Monad$. By providing them, \textbf{GetSet} becomes $get_j\ >>=\ set_j\ =\
return()$, which is exactly one of the laws from $MonadState$. In fact, lens
laws turn into $MonadState$ laws when we abstract away from $State[S, ?]$. As a
result, we determine that the essence of a lens is literally $MonadState$.

\section{Natural implementation of lenses}
\label{sec:Natural}

Once our lenses algebras are defined, we could be interested in combining them,
just as plain lenses are combined. However, when we move composition to this
scenario, the situation becomes more complicated. As we saw in the person
example (section~\ref{sec:Introduction}), lenses compose when the focus of the
first lens matches the whole of the second one. However, our optic algebras have
a type constructor $F[?]$ as weird whole and a concrete type $A$ as focus, which
leads to an odd scenario.

Therefore, we need to ask ourselves what does it mean to compose a pair of lens
algebras. To do so, we will suppose that we have defined the corresponding optic
algebras to the optics we described in the person example:

\begin{lstlisting}
def addressAlg: LensAlg[F[_], Address]
def zipAlg: LensAlg[G[_], Int]
\end{lstlisting}

At this point, we do not know much about them, but we may guess from the context
that \lstinline{adressAlg} should be hiding somehow the state of a $Person$
while granting accessors to its $Address$ part, while $zipAlg$ encapsulates an
$Address$, providing accessors to the $Int$ zip code. Therefore, if we compose
$addressAlg$ with $zipAlg$ we should end up with a lens whose type would be
close to \lstinline{LensAlg[F[_], Address]}, i.e. an algebra that hides a person
and put focus on the zip code associated to its address. However, this
composition is not possible, since it requires a morphism \lstinline{G ~> F} to
be implemented.

Unfortunately, we know now that lens algebras do not compose. However, along the
way, we found an interesting clue: we need some kind of morphism to compose
them. This is interesting, since there are further connections between monad
morphisms and lenses~\cite{abou2015notions}. Having said so, we would like to
instantiate lens algebra buttons with a morphism-alike representation, to
restore composition. This morphism should transform programs on the part into
programs on the whole. Following these intuitions, we get the following
abstraction:

\begin{lstlisting}
case class NatLensAlg[P[_], Q[_], A](
    hom: Q ~> P)(implicit
    MS: MonadState[A, Q]) extends LensAlg[P, A] {
  def get(): P[A] = hom(MS.get)
  def put(a: A): P[Unit] = hom(MS.put(a))
}
\end{lstlisting}

\lstinline{NatLensAlg} takes three type parameters. The first of them represents
the outer program, that knows how to access the whole. On the other hand, the
second one, or inner program, knows how to access the focus. The type of the
focus is determined by the third type parameter. This abstraction takes one
value parameter \lstinline{hom}, which corresponds with the monad homomorphism
that enables composition.

However, if we want to instantiate \lstinline{LensAlg}, we need to provide an
implementation for \lstinline{get} and \lstinline{set}. There is no way to
provide such implementations solely with the monad morphism \lstinline{hom}.
Thereby, we need to determine what particular inner programs are the ones that
become \lstinline{get} and \lstinline{set} when passed through the homomorphism.
If we assume that our inner program is an instance of \lstinline{MonadState[A, ?]},
this is the same as providing a homomorphism for that algebra among
\lstinline{Q} and \lstinline{P}.

Now, we can declare a method to compose natural lens algebras. Indeed, it
becomes trivial when using this representation, we simply compose monad
morphisms:

\begin{lstlisting}
def compose[P[_], Q[_], R[_], B](
    ln1: NatLensAlg[P, Q, A]
    ln2: NatLensAlg[Q, R, B])(implicit
    MS1: MonadState[A, Q],
    MS2: MonadState[B, R]): NatLensAlg[P, R, B] =
  NatLensAlg(ln1.hom compose ln2.hom)
\end{lstlisting}

Coming back to the guiding person example, we can reformulate our original
lenses as natural lens algebras and compose them:

\begin{lstlisting}
def addressNat: NatLensAlg[F[_], Address]
def zipNat: NatLensAlg[G[_], Int]
def compNat: NatLensAlg[F[_], Int] =
  addressNat compose zipNat
\end{lstlisting}

Notice that we are still working at a high level of abstraction. In fact, we
have no idea about how are \lstinline{F[_]} or \lstinline{G[_]} handling their
encapsulated state. As long as \lstinline{hom} is a monad morphism, our composed
lens expresses that we can access or update the nested part from the whole, no
matter the particular configuration where it is deployed.

\section{Generalizing to other optics}
\label{sec:Generalizing}

Lens composition is fundamental to deal with nested data structures, but optics
really shine when they are composed
heterogeneously~\cite{pickering2017profunctor}. Therefore, in order to take
optic benefits to the algebraic setting, we need to describe other optic
algebras and be able to compose them. In this section, we introduce \emph{affine
algebras} and \emph{traversal algebras}. For each of them, we will show a very
brief introduction, we will extract its algebraic essence and finally, we will
show a composable representation.

\subsection{Affine Algebra}

A lens implies that the part is always present in the whole, however this could
not be the case in other scenarios. Affine\footnote{This optic is also known as
\emph{affine traversal}, \emph{affine lens} or even \emph{optional} in the
folklore.} comes to alleviate this situation by evidencing that the part could
be unavailable from the whole:

\begin{lstlisting}
case class Affine[S, A](
  getOption: S => Option[A],
  set: (S, A) => S)
\end{lstlisting}

If we derive the essence of the affine, as we did in section~\ref{sec:Towards}
for lens, we end up with the following definition for affine algebras:

\begin{lstlisting}
trait AffineAlg[F[_], A] extends Monad[F] {
  def getOption(): F[Option[A]]
  def set(a: A): F[Unit]
}
\end{lstlisting}

As for the lens algebra case, it does not make much sense to compose affine
algebras. We need to find a morphism representation to enable this feature.
Intuitively, an inner program that modifies the part should be transformed into
an outer program that optionally modifies the whole, just in case the part does
exist. This intuition lead us to the following representation:

\begin{lstlisting}
case class NatAffineAlg[P[_], Q[_], A](
    hom: Q ~> P[Option[?]])(implicit
    MS: MonadState[A, Q]) extends AffineAlg[P, A] {
  def getOption(): P[Option[A]] = hom(MS.get)
  def put(a: A): P[Option[Unit]] = hom(MS.put(a))
}
\end{lstlisting}

In fact, if we instantiate this algebra for
\lstinline{NatAffineAlg[State[S, ?], State[A, ?], A]} we get something
isomorphic to \lstinline{Affine[S, A]}, which supports the new algebra
definition. Now that we have a composable representation, we should be able to
compose a pair of affine algebras:

\begin{lstlisting}
def compose[P[_], Q[_], R[_], B](
    af1: NatAffineAlg[P, Q, A]
    af2: NatAffineAlg[Q, R, B])(implicit
    MS1: MonadState[A, Q],
    MS2: MonadState[B, R]): NatAffineAlg[P, R, B] =
  NatAffineAlg((af1.hom compose af2.hom).map(_.join))
\end{lstlisting}

And what is even more interesting, we should be able to compose optics
heterogeneously, for instance, a lens algebra with an affine algebra:

\begin{lstlisting}
def compose[P[_], Q[_], R[_], B](
    ln: NatLensAlg[P, Q, A]
    af: NatAffineAlg[Q, R, B])(implicit
    MS1: MonadState[A, Q],
    MS2: MonadState[B, R]): NatAffineAlg[P, R, B] =
  NatLensAlg(ln.hom compose af.hom)
\end{lstlisting}

This composition results in an affine algebra, which is pretty consistent with
classic optic composition, where the result of composing a lens with an affine
is itself an affine. Notice as well that reversing the composing optic types,
eg: composing an affine algebra with a lens algebra, does not affect the
resulting type.

\subsection{(Weak) Traversal Algebra}

While lenses and affines do focus on a single part, which could or could not
exist, we lack something to focus on a sequence of parts, which is exactly what
traversals are for. This optic turns out to be tricky and it is not possible to
represent it as a bunch of simple functions~\cite{oconnor2011functor}.
Therefore, we will use a relaxed version, which we call \emph{Weak Traversal}:

\begin{lstlisting}
case class WTraversal[S, A](
  getAll: S => List[A],
  modify: (A => A) => S => S)
\end{lstlisting}

This optic is constrained in the sense that the modification that we achieve
over each part must be exactly the same, but we find it good enough for most of
cases. If we derive the essence of a weak traversal, we get the following
interface:

\begin{lstlisting}
trait WTraversalAlg[F[_], A] extends Monad[F] {
  def getList(): F[List[A]]
  def modify(f: A => A): F[List[Unit]]
}
\end{lstlisting}

As usual, we need to find a composable representation for these traversal
algebras. If we apply the same ideas that we used for affine algebras, we get
the next representation, where the possibility of failing focus is replaced with
the possibility of multiple focus:

\begin{lstlisting}
case class NatWTraversalAlg[P[_], Q[_], A](
    hom: Q ~> P[List[?]])(implicit
    MS: MonadState[A, Q]) extends WTraversalAlg[P, A] {
  def getList() = hom(MS.get)
  def modify(f: A => A) = hom(MS.put(a))
}
\end{lstlisting}

Again, if we instantiate this algebra for
\lstinline{NatWTraversalAlg[State[S, ?], State[A, ?], A]} we get something
isomorphic to \lstinline{WTraversal[S, A]}. Now that we have a composable
representation, we should be able to compose homogeneously:

\begin{lstlisting}
def compose[P[_], Q[_], R[_], B](
    af1: NatWTraversalAlg[P, Q, A]
    af2: NatWTraversalAlg[Q, R, B])(implicit
    MS1: MonadState[A, Q],
    MS2: MonadState[B, R]): NatWTraversalAlg[P, R, B] =
  NatWTraversalAlg((af1.hom compose af2.hom).map(_.join))
\end{lstlisting}

And besides, we should be able to compose optics heterogeneously, for instance,
a lens algebra with a traversal algebra:

\begin{lstlisting}
def compose[P[_], Q[_], R[_], B](
    ln: NatLensAlg[P, Q, A]
    af: NatTraversalAlg[Q, R, B])(implicit
    MS1: MonadState[A, Q],
    MS2: MonadState[B, R]): NatTraversalAlg[P, R, B] =
  NatTraversalAlg(ln.hom compose af.hom)
\end{lstlisting}

As expected by optic composition rules, composing lens algebras with traversal
algebras results in traversal algebras. Had we composed with an affine algebra
instead, it would have resulted in a traversal algebra.

\section{Stateless: an optic algebra Scala library}
\label{sec:Stateless}

% Indexed, Lib, etc.

% Example: university / geofence

\section{Related Work}
\label{sec:Discussion}

\section{Conclusion}

% Weak Algebra, Prism Algebra, etc.

% Ignoring polymorphic STAB

\section*{Acknowledgements}
MINECO

\bibliography{stateless}{}
\bibliographystyle{unsrt}

\end{document}
