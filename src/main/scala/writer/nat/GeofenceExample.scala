package org.hablapps.stateless
package writer
package nat

import scalaz._, Id.Id
import scalaz.std.list._
import scalaz.syntax.id._

import core.nat.LensAlg

object GeofenceExample extends App with LensWriter {

  type Region = Long
  type DID = Long

  trait Geofence[P[_]] {

    /* OPTICS */
    val regionLn: LensAlg[P, Region]
    val insideLn: LensAlg[P, Set[DID]]

    /* DERIVED */
    def addInside(did: DID): P[Unit] = insideLn.modify(_ + did)
    def removeInside(did: DID): P[Unit] = insideLn.modify(_ - did)

  }

  /* This whole companion object should be auto-generated by azúcar */
  object Geofence {
    import core.Iso

    // type Aux = "regionLn" ->> regionLn.type :+: "insideLn" ->> insideLn.type :+: CNil
    // or...
    sealed abstract class ADT[P[_], A]
    case class RegionLn[P[_], A](internal: LensAlg.ADT[P, A]) extends ADT[P, A]
    case class InsideLn[P[_], A](internal: LensAlg.ADT[P, A]) extends ADT[P, A]
    case class AddInside[P[_]](did: DID) extends ADT[P, Unit]
    case class RemoveInside[P[_]](did: DID) extends ADT[P, Unit]

    implicit def geofenceIso(implicit
        regionIso: Iso.Aux[LensAlg[?[_], Region], LensAlg.ADT],
        insideIso: Iso.Aux[LensAlg[?[_], Set[DID]], LensAlg.ADT]) =
      new GeofenceIsoClass

    class GeofenceIsoClass(implicit
        regionIso: Iso.Aux[LensAlg[?[_], Region], LensAlg.ADT],
        insideIso: Iso.Aux[LensAlg[?[_], Set[DID]], LensAlg.ADT])
        extends Iso[Geofence] {
      type ADT[P2[_], X] = Geofence.ADT[P2, X]

      def mapHK[P[_], Q[_]](nat: P ~> Q) = new (ADT[P, ?] ~> ADT[Q, ?]) {
        def apply[A](pa: ADT[P, A]): ADT[Q, A] = pa match {
          case RegionLn(internal) => RegionLn(internal |> regionIso.mapHK(nat).apply)
          case InsideLn(internal) => InsideLn(internal |> insideIso.mapHK(nat).apply)
          case AddInside(did) => AddInside(did)
          case RemoveInside(did) => RemoveInside(did)
        }
      }

      def kind[P[_], X](adt: ADT[P, X]): Iso.Kind = adt match {
        case RegionLn(internal) => regionIso.kind(internal)
        case InsideLn(internal) => insideIso.kind(internal)
        case AddInside(did) => Iso.Command
        case RemoveInside(did) => Iso.Command
      }

      def recover[P[_]: Monad](transf: λ[α=>(ADT[P, α], P[α])] ~> P) = λ[λ[α=>(ADT[P, α], P[α])] ~> P] { t => t._1 match {
        case RegionLn(internal) =>
          regionIso.recover[P](
            λ[λ[α=>(regionIso.ADT[P, α], P[α])] ~> P] { x => transf(RegionLn(x._1), x._2) }
            ).apply((internal, t._2))
        case InsideLn(internal) =>
          insideIso.recover[P](
            λ[λ[α=>(insideIso.ADT[P, α], P[α])] ~> P] { x => transf(InsideLn(x._1), x._2) }
            ).apply((internal, t._2))
        case _ =>
          transf(t)
      }}

      def to[P[_]](fp: Geofence[P]): ADT[P, ?] ~> P =
        new (ADT[P, ?] ~> P) {
          def apply[A](adtA: ADT[P, A]): P[A] = adtA match {
            case RegionLn(internal) => regionIso.to[P](fp.regionLn) |> { _(internal) }
            case InsideLn(internal) => insideIso.to[P](fp.insideLn) |> { _(internal) }
            case AddInside(did) => fp.addInside(did)
            case RemoveInside(did) => fp.removeInside(did)
          }
        }
      def from[P[_]](gp: ADT[P, ?] ~> P): Geofence[P] =
        new Geofence[P] {
          val regionLn: LensAlg[P, Region] =
            regionIso.from[P](new (LensAlg.ADT[P, ?] ~> P) {
              def apply[X](l: LensAlg.ADT[P, X]): P[X] =
                gp(RegionLn[P, X](l))
            })
            // regionIso.from[P](λ[LensAlg.ADT[P, Region, ?] ~> P] { l => RegionLn(l) |> gp })
          val insideLn: LensAlg[P, Set[DID]] =
            insideIso.from[P](new (LensAlg.ADT[P, ?] ~> P) {
              def apply[X](l: LensAlg.ADT[P, X]): P[X] =
                gp(InsideLn(l))
            })

          override def addInside(did: DID): P[Unit] = gp(AddInside(did))
          override def removeInside(did: DID): P[Unit] = gp(RemoveInside(did))
        }
    }

  }

  /* EXAMPLE 1: AD HOC INSTANTIATION */

  import monocle.macros.Lenses
  @Lenses case class SGeofence(region: Region, inside: Set[DID])

  // Id Lenses
  val regionId: LensAlg[StateT[Id, SGeofence, ?], Region] = smonocle.nat.all.asLens(SGeofence.region)
  val insideId: LensAlg[StateT[Id, SGeofence, ?], Set[DID]] = smonocle.nat.all.asLens(SGeofence.inside)

  object AdHocInstantiation {
    // WriterT Lenses
    implicit val nat = NaturalTransformation.refl[WriterT[Id, List[String], ?]]
    val region = fromLens[Id, WriterT[Id, List[String], ?], SGeofence, Region](regionId, l => s"regionLn.$l")
    val inside = fromLens[Id, WriterT[Id, List[String], ?], SGeofence, Set[DID]](insideId, l => s"insideLn.$l")

    // Geofence entity
    type P[X] = StateT[WriterT[Id, List[String], ?], SGeofence, X]
    val geo = new Geofence[P] {
      val regionLn: LensAlg[P, Region] = region
      val insideLn: LensAlg[P, Set[DID]] = inside
    }

    implicit val _1 = IndexedStateT.stateTMonadState[SGeofence, WriterT[Id, List[String], ?]]
    val prog = progGen(geo)

    def run = {
      val res = prog.eval(SGeofence(1, Set(2, 3, 4)))

      println(s"RES: $res")
      println(s"RES-VALUE: ${res.value}")
      println(s"RES-WRITTEN: ${res.written}")
    }

  }

  /* EXAMPLE 2: GENERIC INSTANTIATION */

  object GenericInstantiation {
    import GenWriter.ButtonPressed

    /* TYPES */
    type P[X] = StateT[Id, SGeofence, X]
    type QW[X] = WriterT[Id, List[ButtonPressed], X]
    type Q[X] = StateT[QW, SGeofence, X]

    val geoAux = new Geofence[P] {
      val regionLn: LensAlg[P, Region] = regionId
      val insideLn: LensAlg[P, Set[DID]] = insideId
    }

    val iso: core.Iso.Aux[Geofence, Geofence.ADT] =
      Geofence.geofenceIso(
        LensAlg.lensIso[StateT[Id, Region, ?], Region]
          .asInstanceOf[core.Iso.Aux[LensAlg[?[_], Region], LensAlg.ADT]],
        LensAlg.lensIso[StateT[Id, Set[DID], ?], Set[DID]]
          .asInstanceOf[core.Iso.Aux[LensAlg[?[_], Set[DID]], LensAlg.ADT]])

    val nat = λ[Q ~> P] { px =>
      StateT { sg => px.run(sg).value }
    }

    val geo: Geofence[Q] = GenWriter.forAPIStateTWriterT[Geofence, Id, SGeofence](iso, geoAux)(nat)

    val prog = progGen2(geo)

    def run = {
      val res = prog.eval(SGeofence(1, Set(2, 3, 4)))

      println(s"RES: $res")
      println(s"RES-VALUE: ${res.value}")
      println(s"RES-WRITTEN: ${res.written}")
    }

  }

  /* EXAMPLE 3: WITH KAFKA */

  object KafkaInstantiation {
    import java.util.Properties
    import kafka.nat.GenKafka
    import org.apache.kafka.clients.producer.{Producer, KafkaProducer}
    import scala.concurrent.Future
    import scala.concurrent.ExecutionContext.Implicits.global
    import scalaz.std.scalaFuture._

    /* TYPES */
    type Q[X] = StateT[Future, (Producer[Unit, String], SGeofence), X]

    val geo: Geofence[Q] = GenKafka.stateT(
      GenericInstantiation.iso,
      GenericInstantiation.geo)

    val prog = progGen2(geo)

    def run = {
      import scala.concurrent.Await
      import scala.concurrent.duration._

      val propsP: Properties = new Properties()
      propsP.put("bootstrap.servers", "localhost:9092")
      propsP.put("acks", "all")
      propsP.put("retries", "0")
      propsP.put("batch.size", "16384")
      propsP.put("linger.ms", "1")
      propsP.put("buffer.memory", "33554432")
      propsP.put("key.serializer", "org.apache.kafka.common.serialization.StringSerializer")
      propsP.put("value.serializer", "org.apache.kafka.common.serialization.StringSerializer")

      val producer = new KafkaProducer[Unit, String](propsP)

      val res = Await.result(prog.eval((producer, SGeofence(1, Set(2, 3, 4)))), 10 seconds)
      println(s"RES: $res")
    }

  }

  /* PROGRAMS */

  import scalaz.syntax.monad._
  def progGen[P[_]: Monad](geo: Geofence[P]) =
    for {
      _ <- geo.regionLn.get
      _ <- geo.insideLn.get
      _ <- geo.regionLn.put(5)
      _ <- geo.insideLn.put(Set(6, 7, 8))
      reg <- geo.regionLn.get
      ins <- geo.insideLn.get
    } yield (reg, ins)

  def progGen2[P[_]: Monad](geo: Geofence[P]) =
    for {
      _ <- geo.regionLn.modify(_ * 10)
      // _ <- geo.insideLn.modify(_ - 3)
      res1 <- geo.insideLn.get
      _ <- geo.removeInside(3)
      _ <- geo.addInside(10)
      res2 <- geo.insideLn.get
    } yield (res1, res2)

  // AdHocInstantiation.run
  // GenericInstantiation.run
  KafkaInstantiation.run

}
