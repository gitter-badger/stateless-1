package org.hablapps.stateless
package geofence

import scalaz.{Monad, ~>}
import scalaz.syntax.id._

import core.nat.LensAlg

trait Geofence[P[_]] {

  /* OPTICS */
  val regionLn: LensAlg[P, Region]
  val insideLn: LensAlg[P, Set[DID]] // TODO(jfuentes): protected PUT public GET ?

  /* DERIVED */
  def addInside(did: DID): P[Unit] = insideLn.modify(_ + did)
  def removeInside(did: DID): P[Unit] = insideLn.modify(_ - did)

}

/* This whole companion object should be auto-generated by azúcar */
object Geofence {
  import core.{Iso, CirceSerializer, CQRS}

  // type Aux = "regionLn" ->> regionLn.type :+: "insideLn" ->> insideLn.type :+: CNil
  // or...
  sealed abstract class ADT[A]
  case class RegionLn[A](internal: LensAlg.ADT[A]) extends ADT[A]
  case class InsideLn[A](internal: LensAlg.ADT[A]) extends ADT[A]
  case class AddInside(did: DID) extends ADT[Unit]
  case class RemoveInside(did: DID) extends ADT[Unit]

  def geofenceCirceSerializer(implicit
      regionIso: CirceSerializer[LensAlg.ADT],
      insideIso: CirceSerializer[LensAlg.ADT]): CirceSerializer[Geofence.ADT] =
    new  CirceSerializer[Geofence.ADT] {

      import io.circe.Json
      def toJSON[A](adt: ADT[A]): Json = adt match {
        case RegionLn(internal) =>
          Json.obj(
            "name" -> Json.fromString("RegionLn"),
            "internal" -> regionIso.toJSON(internal))
        case InsideLn(internal) =>
          Json.obj(
            "name" -> Json.fromString("InsideLn"),
            "internal" -> insideIso.toJSON(internal))
        case AddInside(did) =>
          Json.obj(
            "name" -> Json.fromString("AddInside"),
            "did" -> Json.fromLong(did))
        case RemoveInside(did) =>
          Json.obj(
            "name" -> Json.fromString("RemoveInside"),
            "did" -> Json.fromLong(did))
      }
      def fromJSON(json: Json): ADT[_] =
        json.hcursor.downField("name").as[String] match {
          case Right("RegionLn") =>
            (for {
              internal <- json.hcursor.downField("internal").as[Json]
            } yield RegionLn(regionIso.fromJSON(internal))).getOrElse(???)
          case Right("InsideLn") =>
            (for {
              internal <- json.hcursor.downField("internal").as[Json]
            } yield InsideLn(insideIso.fromJSON(internal))).getOrElse(???)
          case Right("AddInside") =>
            json.hcursor.downField("did").as[Long]
              .map(AddInside(_))
              .getOrElse(???)
          case Right("RemoveInside") =>
            json.hcursor.downField("did").as[Long]
              .map(RemoveInside(_))
              .getOrElse(???)
          case _ => ??? // Deserialization error
        }
    }

  implicit def geofenceCQRS(implicit
      regionCQRS: CQRS[LensAlg.ADT],
      insideCQRS: CQRS[LensAlg.ADT]) = new CQRS[ADT] {

    def kind[X](adt: ADT[X]): CQRS.Kind = adt match {
      case RegionLn(internal) => regionCQRS.kind(internal)
      case InsideLn(internal) => insideCQRS.kind(internal)
      case AddInside(did) => CQRS.Command
      case RemoveInside(did) => CQRS.Command
    }
  }

  implicit def geofenceIso(implicit
      regionIso: Iso.Aux[LensAlg[?[_], Region], LensAlg.ADT, Monad],
      insideIso: Iso.Aux[LensAlg[?[_], Set[DID]], LensAlg.ADT, Monad]) =
    new GeofenceIsoClass

  class GeofenceIsoClass(implicit
      regionIso: Iso.Aux[LensAlg[?[_], Region], LensAlg.ADT, Monad],
      insideIso: Iso.Aux[LensAlg[?[_], Set[DID]], LensAlg.ADT, Monad])
      extends Iso[Geofence] {
    type ADT[X] = Geofence.ADT[X]
    type Ev[P2[_]] = Monad[P2]

    def to[P[_]](fp: Geofence[P]): ADT ~> P =
      new (ADT ~> P) {
        def apply[A](adtA: ADT[A]): P[A] = adtA match {
          case RegionLn(internal) => regionIso.to[P](fp.regionLn) |> { _(internal) }
          case InsideLn(internal) => insideIso.to[P](fp.insideLn) |> { _(internal) }
          case AddInside(did) => fp.addInside(did)
          case RemoveInside(did) => fp.removeInside(did)
        }
      }
    def from[P[_]: Monad](gp: ADT ~> P): Geofence[P] =
      new Geofence[P] {
        val regionLn: LensAlg[P, Region] =
          regionIso.from[P](new (LensAlg.ADT ~> P) {
            def apply[X](l: LensAlg.ADT[X]): P[X] =
              gp(RegionLn(l))
          })
          // regionIso.from[P](λ[LensAlg.ADT[P, Region, ?] ~> P] { l => RegionLn(l) |> gp })
        val insideLn: LensAlg[P, Set[DID]] =
          insideIso.from[P](new (LensAlg.ADT ~> P) {
            def apply[X](l: LensAlg.ADT[X]): P[X] =
              gp(InsideLn(l))
          })

        override def addInside(did: DID): P[Unit] = gp(AddInside(did))
        override def removeInside(did: DID): P[Unit] = gp(RemoveInside(did))
      }
  }

}
